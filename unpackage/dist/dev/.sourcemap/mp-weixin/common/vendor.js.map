{"version":3,"sources":["webpack:///./node_modules/@dcloudio/uni-mp-vue/dist/vue.runtime.esm.js?dc04","webpack:///./node_modules/@dcloudio/uni-mp-weixin/dist/uni.api.esm.js?d5d0","webpack:///./node_modules/@vue/shared/dist/shared.esm-bundler.js?9ff4","webpack:///(webpack)/buildin/global.js?cd00","webpack:///./node_modules/@dcloudio/uni-mp-weixin/dist/uni.mp.esm.js?97ff","webpack:///./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js?f0c5"],"names":["API_TYPE_SYNC","validateProtocol","_name","_args","_protocol","formatApiArgs","args","options","createApi","fn","protocol","type","name","process","apply","Upx2pxProtocol","Number","String","required","EPS","BASE_DEVICE_WIDTH","isIOS","deviceWidth","deviceDPR","checkDeviceWidth","wx","getSystemInfoSync","platform","pixelRatio","windowWidth","upx2px","number","newDeviceWidth","result","Math","floor","HOOKS","globalInterceptors","scopedInterceptors","wrapperHook","hook","data","queue","hooks","promise","i","length","Promise","resolve","res","then","catch","callback","wrapperOptions","interceptors","SUCCESS","FAIL","COMPLETE","forEach","oldCallback","callbackInterceptor","wrapperReturnValue","method","returnValue","returnValueHooks","push","interceptor","getApiInterceptorHooks","Object","create","keys","slice","scopedInterceptor","concat","invokeApi","api","params","invoke","AddInterceptorProtocol","RemoveInterceptorProtocol","mergeInterceptorHook","mergeHook","removeInterceptorHook","removeHook","parentVal","childVal","dedupeHooks","indexOf","index","splice","addInterceptor","removeInterceptor","SYNC_API_RE","CONTEXT_API_RE","CONTEXT_API_RE_EXC","ASYNC_API","CALLBACK_API_RE","isContextApi","test","isSyncApi","isCallbackApi","handlePromise","err","shouldPromise","prototype","finally","onfinally","constructor","value","reason","promisify","promiseApi","success","fail","complete","reject","assign","CALLBACKS","initWrapper","protocols","processCallback","methodName","processReturnValue","processArgs","fromArgs","argsOption","keepFromArgs","toArgs","key","keyOption","console","warn","keepReturnValue","wrapper","error","arg1","arg2","baseApis","initUni","UniProxyHandlers","get","target","Proxy","initGetProvider","providers","getProvider","service","errMsg","provider","previewImage","currentIndex","parseInt","current","isNaN","urls","len","filter","item","indicator","loop","addSafeAreaInsets","fromRes","toRes","safeArea","safeAreaInsets","top","left","right","bottom","windowHeight","getSystemInfo","redirectTo","createCanvasContext","measureText","text","textMetrics","call","setTimeout","oauth","share","payment","shims","freeze","__proto__","setModel","modifiers","trim","setSync","getOrig","$orig","map","val","iteratee","ret","l","Array","MP_METHODS","createEmitFn","oldEmit","ctx","emit","event","$scope","triggerEvent","__args__","initBaseInstance","instance","mpType","$mpType","mpInstance","$mp","__VUE_OPTIONS_API__","_self","$vm","proxy","slots","initComponentInstance","__set_model","__set_sync","__get_orig","__map","initMocks","mocks","mock","PAGE_HOOKS","findHooks","vueOptions","Set","add","extendsOptions","extends","mixins","mixin","initHook","mpOptions","excludes","$callHook","EXCLUDE_HOOKS","initHooks","initUnknownHooks","parseApp","parseAppOptions","internalInstance","$","appOptions","globalData","$options","onLaunch","methods","parse","initCreateApp","createApp","vm","App","encode","encodeURIComponent","stringifyQuery","obj","encodeStr","undefined","JSON","stringify","x","join","initBehavior","Behavior","initVueIds","vueIds","ids","split","_$vueId","_$vuePid","EXTRAS","initExtraOptions","miniProgramComponentOptions","initWxsCallMethods","wxsCallMethods","callMethod","initRefs","defineProperty","$refs","components","selectAllComponents","component","ref","dataset","forComponents","findVmByVueId","vuePid","$children","childVm","parentVm","PROP_TYPES","Boolean","createObserver","observer","newVal","props","parsePropType","defaultValue","initDefaultProps","isBehavior","properties","vueId","vueSlots","$slots","slotName","setData","createProperty","prop","initProps","mpComponentOptions","rawProps","opts","default","initData","appConfig","getApp","appContext","config","globalProperties","e","VUE_APP_DEBUG","initBehaviors","vueBehaviors","behaviors","vueExtends","vueMixins","vueProps","behavior","replace","__PLATFORM_PREFIX__","Date","vueMixin","applyOptions","componentOptions","getValue","path","parts","getExtraValue","dataPathsArray","context","dataPathArray","dataPath","propPath","valuePath","vFor","isInteger","substr","find","vForItem","vForKey","processEventExtra","extra","extraObj","detail","getObjByArray","arr","element","processEventArgs","isCustom","isCustomMPEvent","currentTarget","comType","arg","stopPropagation","NOOP","preventDefault","markerId","ONCE","CUSTOM","matchEventType","eventType","optType","handleEvent","eventOpts","eventOpt","eventsArray","charAt","isOnce","eventArray","handlerCtx","generic","$parent","$emit","handler","Error","once","parseComponent","isPage","initRelation","handleLink","initLifetimes","multipleSlots","addGlobalClass","lifetimes","pageLifetimes","show","hide","resize","size","__l","__e","initCreateComponent","parseOptions","createComponent","vueComponentOptions","Component","$createComponentFn","$destroyComponentFn","$createComponent","initialVNode","$destroyComponent","parsePage","miniProgramPageOptions","onLoad","query","$page","fullPath","route","initCreatePage","createPage","vuePageOptions","MPPage","Page","MPComponent","customizeRE","customize","str","initTriggerEvent","oldTriggerEvent","initHook$1","oldHook","attached","relationOptions","parentComponent","parent","onBeforeSetup","ready","detached"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4Y;AACrW;;AAEvC;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,KAAqC,gBAAgB,SAAE;AACnF,oCAAoC,KAAqC,wBAAwB,SAAE;AACnG;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAO;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAO;AAC5B;AACA,wBAAwB,yDAAK;AAC7B;AACA;AACA;AACA,yBAAyB,gEAAY;AACrC;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAO;AAC5B;AACA,wBAAwB,yDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,2DAAO;AAChD;AACA;AACA,YAAY,oDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAO;AACrC,4CAA4C,0DAAM;AAClD;AACA;AACA;AACA,YAAY,4DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gEAAY;AAChE;AACA;AACA,YAAY,4DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAO;AACxB;AACA;AACA;AACA;AACA,uBAAuB,2DAAO,YAAY,gEAAY;AACtD;AACA,cAAc,0DAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4DAAQ;AACjB;AACA;AACA;AACA;AACA;AACA,2CAA2C,2DAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAqC;AAClD,kDAAkD,YAAY;AAC9D;AACA;AACA,KAAK;AACL;AACA,aAAa,IAAqC;AAClD,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA,gCAAgC,0DAAM,GAAG;AACzC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,gCAAgC,0DAAM,GAAG;AACzC;AACA,CAAC;;AAED,8BAA8B,4DAAQ;AACtC,8BAA8B,4DAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc,IAAqC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc,IAAqC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAqC;AAC5D,UAAU,yDAAK;AACf;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAqC;AAClD,6CAA6C,QAAQ;AACrD,4BAA4B,8DAAU,OAAO,aAAa,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAS;AAC9B,iCAAiC,KAAK;AACtC,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4DAAQ;AACjB,aAAa,IAAqC;AAClD,2DAA2D,eAAe;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAG;AACP;AACA;;AAEA,yBAAyB,4DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAqC,gBAAgB,SAAM;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAqC;AAC9C;AACA;AACA,gBAAgB,2DAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAU;AAClB;AACA,kBAAkB,KAAqC;AACvD;AACA;AACA;AACA,cAAc,SAAI;AAClB;AACA;AACA;AACA;AACA;AACA,+CAA+C,8DAAU;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,YAAY,0CAA0C;AACrF;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B,sBAAsB;AACjD,+CAA+C,aAAa;AAC5D;AACA,yBAAyB,yDAAyD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAQ;AAChB;AACA,iCAAiC,IAAI,GAAG,MAAM;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,IAAI,GAAG,MAAM;AAC9C;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA,aAAa,8DAAU;AACvB,mBAAmB,IAAI,KAAK,iBAAiB,WAAW,QAAQ;AAChE;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAU;AAClB;AACA,mBAAmB,6DAAS;AAC5B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAqC,qCAAqC,SAAI,CAAC;AAC1G;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C,oDAAoD;AACpD;AACA;AACA;AACA,+BAA+B,+BAA+B,KAAK,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,EAGJ;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2DAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAqC;AAClD;AACA;AACA,+BAA+B,0CAA0C;AACzE,iBAAiB,IAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAqC;AAClD;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E,iBAAiB,IAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA,qBAAqB,IAAqC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,qDAAS;AACnD,SAAS,IAAqC;AAC9C,eAAe,6CAA6C;AAC5D;AACA;AACA,uCAAuC,gEAAY;AACnD,qDAAqD,MAAM;AAC3D,uDAAuD,gEAAY,QAAQ;AAC3E;AACA;AACA;AACA;AACA,oBAAoB,8DAAU;AAC9B;AACA;AACA,4FAA4F,MAAM;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAA+C;AAC/E,eAAe,eAAe,0BAA0B,qDAAS;AACjE;AACA;AACA;AACA;AACA,+BAA+B,oDAAQ;AACvC;AACA;AACA,QAAQ,IAAgD;AACxD,SAAS,IAAqC;AAC9C;AACA,8CAA8C,gEAAY;AAC1D,2BAA2B,eAAe;AAC1C,mBAAmB,6CAA6C,sCAAsC,MAAM;AAC5G;AACA;AACA,4CAA4C,6DAAS,QAAQ,gBAAgB,MAAM;AACnF;AACA;AACA;AACA,sBAAsB,gEAAY,CAAC,4DAAQ;AAC3C;AACA;AACA;AACA;AACA,sBAAsB,gEAAY,CAAC,6DAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAmB,KAAK,8DAAU;AAC1C;AACA;AACA;AACA;AACA,gBAAgB,0DAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAO;AACf;AACA;AACA;AACA,QAAQ,0DAAM;AACd;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA,qBAAqB,wDAAI;AACzB;AACA;AACA;AACA,YAAY,0DAAM;AAClB,QAAQ,0DAAM,UAAU,6DAAS;AACjC,QAAQ,0DAAM;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAG;AACP;AACA;AACA;AACA,SAAS,IAAqC;AAC9C,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kEAAc;AAC9B;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAM,sBAAsB,4DAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAM;AACjC;AACA;AACA;AACA,yCAAyC,8DAAU;AACnD,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAM;AACvB;AACA;AACA;AACA,2CAA2C,6DAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAmB,KAAK,8DAAU;AAC1C;AACA;AACA;AACA,YAAY,0DAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAS;AACxC;AACA,QAAQ,2DAAO;AACf,uBAAuB,gBAAgB;AACvC,iBAAiB,KAAqC,MAAM,4DAAQ;AACpE;AACA;AACA,kCAAkC,4DAAQ;AAC1C;AACA,4CAA4C,qDAAS;AACrD;AACA;AACA;AACA;AACA,aAAa,KAAqC,MAAM,4DAAQ;AAChE;AACA;AACA;AACA,kCAAkC,4DAAQ;AAC1C;AACA;AACA;AACA,oBAAoB,2DAAO,SAAS,8DAAU,SAAS,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0DAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAqC;AACnD,oCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAO;AACf,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0DAAM,oBAAoB,0DAAM,WAAW,6DAAS;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAO;AAC7B;AACA;AACA,uBAAuB,8BAA8B;AACrD,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAQ;AACxB;AACA;AACA,gBAAgB,2DAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK;AACpE,qBAAqB,kBAAkB,sDAAU,aAAa;AAC9D;AACA,yBAAyB,6DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA,wBAAwB,aAAa;AACrC;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAqC;AACnD,wBAAwB,gEAAY;AACpC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAqC,MAAM,8DAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAA6C,GAAG,qDAAS;AACvF,SAAS,KAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2DAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAqC;AACtD;AACA,SAAS;AACT;AACA,aAAa,8DAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAI;AACrB,SAAS,KAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,4DAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2DAAO;AACpB,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,aAAa,yDAAK,WAAW,yDAAK;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAM;AACd,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2DAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAqC;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,8CAAE;AAC3B;AACA,gCAAgC;AAChC,qCAAqC;AACrC,6BAA6B,8CAAE;AAC/B;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAQ;AAC1C,aAAa,KAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,qBAAqB,IAAqC;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA,qBAAqB,KAAqC;AAC1D;AACA,mCAAmC,8DAAU;AAC7C;AACA;AACA;AACA,yBAAyB,8DAAU;AACnC;AACA;AACA;AACA,0BAA0B,IAAqC;AAC/D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB,IAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,IAAqC;AACnE;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA,qBAAqB,EAEJ;AACjB;AACA,aAAa;AACb;AACA,qBAAqB,IAAqC;AAC1D;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAqC;AAC1D,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA,qBAAqB,IAAqC;AAC1D;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAqC;AAC1D,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA,qBAAqB,EAAE;AACvB;AACA,uBAAuB,EAAE;AACzB;AACA,qBAAqB,KAAqC;AAC1D,oEAAoE,YAAY;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,WAAW,8DAAU,aAAa,qCAAqC;AACvE;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4DAAQ;AACzC,iCAAiC,8DAAU,CAAC,4DAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC;AAClD,sCAAsC,kBAAkB,IAAI,KAAK;AACjE;AACA;AACA;AACA,cAAc,IAAqC;AACnD,uBAAuB,8DAAU,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAQ;AAC7B,qBAAqB,8DAAU,CAAC,4DAAQ;AACxC;;AAEA,yBAAyB,KAAqC,iBAAiB,SAAS;AACxF,qBAAqB,KAAqC,aAAa,SAAS;AAChF,wBAAwB,KAAqC,gBAAgB,SAAS;AACtF,QAAQ,KAAqC,eAAe,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,uBAAuB,MAAM;AAC7B;AACA,UAAU,4DAAQ,uBAAuB,8DAAU;AACnD,eAAe;AACf;AACA;AACA;AACA,sBAAsB,KAAqC;AAC3D;AACA,MAAM,SAAY;AAClB;AACA;AACA,aAAa,KAAqC;AAClD,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAM,GAAG;AAC7B;AACA,aAAa,sBAAsB;AACnC,sBAAsB,4DAAQ;AAC9B,0BAA0B,kEAAc;AACxC;AACA,YAAY,4DAAQ;AACpB;AACA;AACA,mCAAmC,2DAAO;AAC1C,wBAAwB,0DAAM,GAAG;AACjC;AACA,0BAA0B,kEAAc;AACxC;AACA;AACA;AACA,sBAAsB,4DAAQ;AAC9B;AACA;AACA;AACA,kBAAkB,4DAAQ;AAC1B;AACA,sBAAsB,8DAAU;AAChC;AACA;AACA,SAAS,KAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAqC,uCAAuC,2DAAO;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA,aAAa,2DAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAU;AACvB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAM,GAAG;AACzB,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,gCAAgC,kEAAc;AAC9C;AACA;AACA;AACA,4BAA4B,kEAAc;AAC1C;AACA,qBAAqB,wDAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8DAAU;AACtD;AACA;AACA;AACA,kBAAkB,IAAqC;AACvD,+BAA+B,YAAY;AAC3C;AACA;AACA,cAAc,IAAqC;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,KAAK,aAAa,IAAI,0BAA0B,WAAW;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,W;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,iDAAiD,gDAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAqC,+BAA+B,SAAI;AAC9G,SAAS,IAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAyB;AACjC,YAAY,2DAAO;AACnB,2BAA2B,0BAA0B;AACrD;AACA;AACA,qBAAqB,IAAqC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAqC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAU;AAC1B;AACA;AACA,qBAAqB,IAAqC;AAC1D;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB,EAEJ;AACjB,qBAAqB,IAAqC;AAC1D;AACA;AACA;AACA,sBAAsB,IAAqC;AAC3D,gCAAgC,IAAI,cAAc,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAI;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAU;AAClC;AACA,kBAAkB,8DAAU;AAC5B;AACA,sBAAsB,gDAAI;AAC1B,iBAAiB,KAAqC,aAAa,gDAAI;AACvE,2CAA2C,IAAI;AAC/C;AACA,yBAAyB,8DAAU,SAAS,8DAAU;AACtD;AACA,mBAAmB,KAAqC;AACxD;AACA,2EAA2E,IAAI;AAC/E;AACA,sBAAsB,SAAI;AAC1B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB,IAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,IAAyB;AACjC;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAU;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAM;AAClB,uCAAuC,0DAAM,GAAG;AAChD;AACA;AACA,YAAY,0DAAM;AAClB,uCAAuC,0DAAM,GAAG;AAChD;AACA;AACA;AACA;AACA,QAAQ,KAAwB,EAAE,EAI7B;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA,SAAS,KAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAO;AACf;AACA;AACA,oFAAoF;AACpF;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,qDAAS;AAC5C;AACA;AACA,kBAAkB,IAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,SAAS,KAAqC,MAAM,8DAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAqC,KAAK,6DAAS;AAC5D,sEAAsE;AACtE;AACA;AACA;AACA,SAAS,4DAAQ;AACjB,SAAS,KAAqC;AAC9C;AACA,+BAA+B,qDAAS;AACxC;AACA;AACA;AACA;AACA,QAAQ,0DAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAQ;AAChB;AACA,YAAY,8DAAU;AACtB;AACA;AACA,kBAAkB,IAAqC;AACvD,4DAA4D,IAAI;AAChE;AACA;AACA,aAAa,8DAAU;AACvB;AACA;AACA,aAAa,4DAAQ;AACrB,YAAY,2DAAO;AACnB;AACA;AACA;AACA,4BAA4B,8DAAU;AACtC;AACA;AACA,gBAAgB,8DAAU;AAC1B;AACA;AACA,sBAAsB,IAAqC;AAC3D,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA,cAAc,IAAqC;AACnD,uCAAuC,IAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAA4C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA;AACA,sBAAsB,0DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAM;AAClC;AACA;AACA;AACA,mBAAmB,KAAqC,+BAA+B,SAAO;AAC9F,mBAAmB,KAAqC,+BAA+B,SAAO;AAC9F,mBAAmB,KAAqC,+BAA+B,SAAO;AAC9F,kBAAkB,KAAqC,8BAA8B,SAAM;AAC3F;AACA;AACA;AACA,oBAAoB,KAAmB,6BAA6B,SAAM;AAC1E;AACA;AACA,kBAAkB,KAAmB,2BAA2B,SAAI;AACpE,CAAC;AACD;AACA,SAAS,cAAc;AACvB,eAAe,8DAA8D;AAC7E;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAS,IAAI,0DAAM;AACvD;AACA;AACA;AACA,8BAA8B,qDAAS,IAAI,0DAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAM;AACtB;AACA;AACA;AACA,6BAA6B,qDAAS,IAAI,0DAAM;AAChD;AACA;AACA;AACA,qBAAqB,MAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAS,IAAI,0DAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAM;AAClB;AACA;AACA,kBAAkB,KAAqC;AACvD;AACA,cAAc,4DAAQ;AACtB;AACA;AACA;AACA,yBAAyB,qDAAS;AAClC;AACA,gBAAgB,0DAAM;AACtB,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA,KAAK;AACL,SAAS,cAAc;AACvB,eAAe,wBAAwB;AACvC,2BAA2B,qDAAS,IAAI,0DAAM;AAC9C;AACA;AACA,0BAA0B,qDAAS,IAAI,0DAAM;AAC7C;AACA;AACA,iBAAiB,0DAAM;AACvB,aAAa,KAAqC;AAClD,mDAAmD,IAAI;AACvD;AACA;AACA;AACA,aAAa,KAAqC;AAClD,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;AACA,iBAAiB,KAAqC;AACtD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,SAAS,KAAK,+DAA+D,EAAE;AAC/E;AACA;AACA,sBAAsB,qDAAS,IAAI,0DAAM;AACzC,4BAA4B,qDAAS,IAAI,0DAAM;AAC/C,oDAAoD,0DAAM;AAC1D,YAAY,0DAAM;AAClB,YAAY,0DAAM;AAClB,YAAY,0DAAM;AAClB;AACA;AACA,IAAI,IAAiD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0DAAM,GAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,yEAAqB;AAC5D,aAAa,KAAqC;AAClD,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAI;AACrB,SAAS;AACT,KAAK;AACL;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAI;AACrB,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAI;AACzB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAI;AACrB,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAS;AAChC;AACA,aAAa,qDAAS;AACtB,cAAc,qDAAS;AACvB,eAAe,qDAAS;AACxB,eAAe,qDAAS;AACxB,eAAe,qDAAS;AACxB,cAAc,qDAAS;AACvB,oBAAoB,qDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA,SAAS,EAEJ;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAO;AAC1C;AACA,iDAAiD,8CAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,6FAA6F,KAAqC,sCAAsC,SAAc;AACtL;AACA;AACA,YAAY,6DAAS;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,sBAAsB,IAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAU;AAClB;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAQ;AACrB,aAAa,KAAqC;AAClD;AACA;AACA;AACA;AACA;AACA,YAAY,IAAgD;AAC5D;AACA;AACA;AACA,aAAa,IAAqC;AAClD;AACA;AACA;AACA,cAAc,KAAqC;AACnD,2DAA2D,mDAAmD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gDAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAqC,8CAA8C,gDAAI;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAqC;AAClD;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC;AAClD;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,SAAS,EAOJ;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAU;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAY;AACxC,wBAAwB,gEAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAY;AACxC,wBAAwB,gEAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAY;AAChD,gCAAgC,gEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kGAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kGAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kGAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,IAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,0DAAM,wBAAwB;AACtC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,gBAAgB,kGAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB;AACzB;AACA;AACA;AACA,QAAQ,IAAmB;AAC3B;AACA;AACA;AACA;AACA,0BAA0B,gDAAI;AAC9B;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA;AACA,QAAQ,IAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAgB;AACrD,uCAAuC,kEAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,gBAAgB,kEAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,KAAqC,uCAAuC,SAAiB;AACrG;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;AACA,QAAQ,kEAAgB;AACxB;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAI;AACnC,qDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAU;AAC1B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA,QAAQ,8DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAmB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEosB;;;;;;;;;;;;;uFC9lIpsB,wD;;AAEA,IAAMA,aAAa,GAAG,CAAtB;AACA,SAASC,gBAAT,CAA0BC,KAA1B,EAAiCC,KAAjC,EAAwCC,SAAxC,EAAmD;AAC/C,SAAO,IAAP;AACH;AACD,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,OAA7B,EAAsC;AAClC,MAAI,CAACA,OAAL,EAAc;AACV,WAAOD,IAAP;AACH;AACJ;AACD,SA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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA,4BAA4B,KAAK,EAAE,iDAAiD,KAAK,SAAS;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc,GAAG,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA,iCAAiC;AACjC;AACA;AACA,gCAAgC;AAChC;AACA;AACA,gCAAgC;AAChC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,2BAA2B,IAAI;AAC/B;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAqC;AACxD,sBAAsB;AACtB,MAAM,SAAE;AACR,mBAAmB,KAAqC,wBAAwB,SAAE;AAClF,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEovB;;;;;;;;;;;;AC5fpvB;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;wICnBA;;AAEA,SAASgG,QAAT,CAAkB3C,MAAlB,EAA0Bb,GAA1B,EAA+BpB,KAA/B,EAAsC6E,SAAtC,EAAiD;AAC7C,MAAI,qBAAQA,SAAR,CAAJ,EAAwB;AACpB,QAAIA,SAAS,CAAClG,OAAV,CAAkB,MAAlB,MAA8B,CAAC,CAAnC,EAAsC;AAClCqB,WAAK,GAAGA,KAAK,CAAC8E,IAAN,EAAR;AACH;AACD,QAAID,SAAS,CAAClG,OAAV,CAAkB,QAAlB,MAAgC,CAAC,CAArC,EAAwC;AACpCqB,WAAK,GAAG,sBAASA,KAAT,CAAR;AACH;AACJ;AACD,MAAI,CAACiC,MAAL,EAAa;AACTA,UAAM,GAAG,IAAT;AACH;AACDA,QAAM,CAACb,GAAD,CAAN,GAAcpB,KAAd;AACH;AACD,SAAS+E,OAAT,CAAiB9C,MAAjB,EAAyBb,GAAzB,EAA8BpB,KAA9B,EAAqC;AACjC,MAAI,CAACiC,MAAL,EAAa;AACTA,UAAM,GAAG,IAAT;AACH;AACDA,QAAM,CAACb,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","file":"common/vendor.js","sourcesContent":["import { isSymbol, extend, isMap, isObject, toRawType, def, isArray, isString, isFunction, isPromise, toHandlerKey, remove, EMPTY_OBJ, camelize, capitalize, normalizeClass, normalizeStyle, isOn, NOOP, isGloballyWhitelisted, isIntegerKey, hasOwn, hasChanged, invokeArrayFns as invokeArrayFns$1, makeMap, isSet, NO, toNumber, hyphenate, isReservedProp, EMPTY_ARR, toTypeString } from '@vue/shared';\nexport { camelize } from '@vue/shared';\n\nconst invokeArrayFns = (fns, arg) => {\r\n    let ret;\r\n    for (let i = 0; i < fns.length; i++) {\r\n        ret = fns[i](arg);\r\n    }\r\n    return ret;\r\n};\r\nconst ON_ERROR = 'onError';\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set$1 = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set: set$1,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst shallowReadonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, true)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => isObject(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (hasChanged(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), \"set\" /* SET */, 'value', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), \"set\" /* SET */, 'value', (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, \"get\" /* GET */, 'value'), () => trigger(this, \"set\" /* SET */, 'value'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), \"set\" /* SET */, 'value');\r\n                }\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        if (self._dirty) {\r\n            self._value = this.effect();\r\n            self._dirty = false;\r\n        }\r\n        track(self, \"get\" /* GET */, 'value');\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = (process.env.NODE_ENV !== 'production')\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] || type : type; // fixed by xxxxxxx\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\n// fixed by xxxxxx\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type] || type; // fixed by xxxxxx\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\n// fixed by xxxxxx\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job's id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(job) {\r\n    // the start index should be `flushIndex + 1`\r\n    let start = flushIndex + 1;\r\n    let end = queue.length;\r\n    const jobId = getId(job);\r\n    while (start < end) {\r\n        const middle = (start + end) >>> 1;\r\n        const middleJobId = getId(queue[middle]);\r\n        middleJobId < jobId ? (start = middle + 1) : (end = middle);\r\n    }\r\n    return start;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        const pos = findInsertionIndex(job);\r\n        if (pos > -1) {\r\n            queue.splice(pos, 0, job);\r\n        }\r\n        else {\r\n            queue.push(job);\r\n        }\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkRecursiveUpdates(seen, job);\r\n                }\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\n\nfunction emit(instance, event, ...rawArgs) {\r\n    const props = instance.vnode.props || EMPTY_OBJ;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const { emitsOptions, propsOptions: [propsOptions] } = instance;\r\n        if (emitsOptions) {\r\n            if (!(event in emitsOptions)) {\r\n                if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {\r\n                    warn(`Component emitted event \"${event}\" but it is neither declared in ` +\r\n                        `the emits option nor as an \"${toHandlerKey(event)}\" prop.`);\r\n                }\r\n            }\r\n            else {\r\n                const validator = emitsOptions[event];\r\n                if (isFunction(validator)) {\r\n                    const isValid = validator(...rawArgs);\r\n                    if (!isValid) {\r\n                        warn(`Invalid event arguments: event validation failed for event \"${event}\".`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    let args = rawArgs;\r\n    const isModelListener = event.startsWith('update:');\r\n    // for v-model update:xxx events, apply modifiers on args\r\n    const modelArg = isModelListener && event.slice(7);\r\n    if (modelArg && modelArg in props) {\r\n        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;\r\n        const { number, trim } = props[modifiersKey] || EMPTY_OBJ;\r\n        if (trim) {\r\n            args = rawArgs.map(a => a.trim());\r\n        }\r\n        else if (number) {\r\n            args = rawArgs.map(toNumber);\r\n        }\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production') || false) ;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const lowerCaseEvent = event.toLowerCase();\r\n        if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {\r\n            warn(`Event \"${lowerCaseEvent}\" is emitted in component ` +\r\n                `${formatComponentName(instance, instance.type)} but the handler is registered for \"${event}\". ` +\r\n                `Note that HTML attributes are case-insensitive and you cannot use ` +\r\n                `v-on to listen to camelCase events when using in-DOM templates. ` +\r\n                `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`);\r\n        }\r\n    }\r\n    // convert handler name to camelCase. See issue #2249\r\n    let handlerName = toHandlerKey(camelize(event));\r\n    let handler = props[handlerName];\r\n    // for v-model update:xxx events, also trigger kebab-case equivalent\r\n    // for props passed via kebab-case\r\n    if (!handler && isModelListener) {\r\n        handlerName = toHandlerKey(hyphenate(event));\r\n        handler = props[handlerName];\r\n    }\r\n    if (handler) {\r\n        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n    const onceHandler = props[handlerName + `Once`];\r\n    if (onceHandler) {\r\n        if (!instance.emitted) {\r\n            (instance.emitted = {})[handlerName] = true;\r\n        }\r\n        else if (instance.emitted[handlerName]) {\r\n            return;\r\n        }\r\n        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n}\r\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__emits !== undefined) {\r\n        return comp.__emits;\r\n    }\r\n    const raw = comp.emits;\r\n    let normalized = {};\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\r\n        const extendEmits = (raw) => {\r\n            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);\r\n            if (normalizedFromExtend) {\r\n                hasExtends = true;\r\n                extend(normalized, normalizedFromExtend);\r\n            }\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendEmits);\r\n        }\r\n        if (comp.extends) {\r\n            extendEmits(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendEmits);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__emits = null);\r\n    }\r\n    if (isArray(raw)) {\r\n        raw.forEach(key => (normalized[key] = null));\r\n    }\r\n    else {\r\n        extend(normalized, raw);\r\n    }\r\n    return (comp.__emits = normalized);\r\n}\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nfunction isEmitListener(options, key) {\r\n    if (!options || !isOn(key)) {\r\n        return false;\r\n    }\r\n    key = key.slice(2).replace(/Once$/, '');\r\n    return (hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||\r\n        hasOwn(options, hyphenate(key)) ||\r\n        hasOwn(options, key));\r\n}\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nlet currentScopeId = null;\n\nfunction markAttrsAccessed() {\r\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\r\nisSSR = false) {\r\n    const props = {};\r\n    const attrs = {};\r\n    // def(attrs, InternalObjectKey, 1) // fixed by xxxxxx\r\n    def(attrs, '__vInternal', 1);\r\n    instance.propsDefaults = Object.create(null);\r\n    setFullProps(instance, rawProps, props, attrs);\r\n    // validation\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        validateProps(rawProps || {}, props, instance);\r\n    }\r\n    if (isStateful) {\r\n        // stateful\r\n        instance.props = isSSR ? props : shallowReactive(props);\r\n    }\r\n    else {\r\n        if (!instance.type.props) {\r\n            // functional w/ optional props, props === attrs\r\n            instance.props = attrs;\r\n        }\r\n        else {\r\n            // functional w/ declared props\r\n            instance.props = props;\r\n        }\r\n    }\r\n    instance.attrs = attrs;\r\n}\r\nfunction setFullProps(instance, rawProps, props, attrs) {\r\n    const [options, needCastKeys] = instance.propsOptions;\r\n    if (rawProps) {\r\n        for (const key in rawProps) {\r\n            const value = rawProps[key];\r\n            // key, ref are reserved and never passed down\r\n            if (isReservedProp(key)) {\r\n                continue;\r\n            }\r\n            // prop option names are camelized during normalization, so to support\r\n            // kebab -> camel conversion here we need to camelize the key.\r\n            let camelKey;\r\n            if (options && hasOwn(options, (camelKey = camelize(key)))) {\r\n                props[camelKey] = value;\r\n            }\r\n            else if (!isEmitListener(instance.emitsOptions, key)) {\r\n                // Any non-declared (either as a prop or an emitted event) props are put\r\n                // into a separate `attrs` object for spreading. Make sure to preserve\r\n                // original key casing\r\n                attrs[key] = value;\r\n            }\r\n        }\r\n    }\r\n    if (needCastKeys) {\r\n        const rawCurrentProps = toRaw(props);\r\n        for (let i = 0; i < needCastKeys.length; i++) {\r\n            const key = needCastKeys[i];\r\n            props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);\r\n        }\r\n    }\r\n}\r\nfunction resolvePropValue(options, props, key, value, instance) {\r\n    const opt = options[key];\r\n    if (opt != null) {\r\n        const hasDefault = hasOwn(opt, 'default');\r\n        // default values\r\n        if (hasDefault && value === undefined) {\r\n            const defaultValue = opt.default;\r\n            if (opt.type !== Function && isFunction(defaultValue)) {\r\n                const { propsDefaults } = instance;\r\n                if (key in propsDefaults) {\r\n                    value = propsDefaults[key];\r\n                }\r\n                else {\r\n                    setCurrentInstance(instance);\r\n                    value = propsDefaults[key] = defaultValue(props);\r\n                    setCurrentInstance(null);\r\n                }\r\n            }\r\n            else {\r\n                value = defaultValue;\r\n            }\r\n        }\r\n        // boolean casting\r\n        if (opt[0 /* shouldCast */]) {\r\n            if (!hasOwn(props, key) && !hasDefault) {\r\n                value = false;\r\n            }\r\n            else if (opt[1 /* shouldCastTrue */] &&\r\n                (value === '' || value === hyphenate(key))) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__props) {\r\n        return comp.__props;\r\n    }\r\n    const raw = comp.props;\r\n    const normalized = {};\r\n    const needCastKeys = [];\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\r\n        const extendProps = (raw) => {\r\n            hasExtends = true;\r\n            const [props, keys] = normalizePropsOptions(raw, appContext, true);\r\n            extend(normalized, props);\r\n            if (keys)\r\n                needCastKeys.push(...keys);\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendProps);\r\n        }\r\n        if (comp.extends) {\r\n            extendProps(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendProps);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__props = EMPTY_ARR);\r\n    }\r\n    if (isArray(raw)) {\r\n        for (let i = 0; i < raw.length; i++) {\r\n            if ((process.env.NODE_ENV !== 'production') && !isString(raw[i])) {\r\n                warn(`props must be strings when using array syntax.`, raw[i]);\r\n            }\r\n            const normalizedKey = camelize(raw[i]);\r\n            if (validatePropName(normalizedKey)) {\r\n                normalized[normalizedKey] = EMPTY_OBJ;\r\n            }\r\n        }\r\n    }\r\n    else if (raw) {\r\n        if ((process.env.NODE_ENV !== 'production') && !isObject(raw)) {\r\n            warn(`invalid props options`, raw);\r\n        }\r\n        for (const key in raw) {\r\n            const normalizedKey = camelize(key);\r\n            if (validatePropName(normalizedKey)) {\r\n                const opt = raw[key];\r\n                const prop = (normalized[normalizedKey] =\r\n                    isArray(opt) || isFunction(opt) ? { type: opt } : opt);\r\n                if (prop) {\r\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                    const stringIndex = getTypeIndex(String, prop.type);\r\n                    prop[0 /* shouldCast */] = booleanIndex > -1;\r\n                    prop[1 /* shouldCastTrue */] =\r\n                        stringIndex < 0 || booleanIndex < stringIndex;\r\n                    // if the prop needs boolean casting or default value\r\n                    if (booleanIndex > -1 || hasOwn(prop, 'default')) {\r\n                        needCastKeys.push(normalizedKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (comp.__props = [normalized, needCastKeys]);\r\n}\r\nfunction validatePropName(key) {\r\n    if (key[0] !== '$') {\r\n        return true;\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`Invalid prop name: \"${key}\" is a reserved property.`);\r\n    }\r\n    return false;\r\n}\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor) {\r\n    const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n    return match ? match[1] : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (isArray(expectedTypes)) {\r\n        for (let i = 0, len = expectedTypes.length; i < len; i++) {\r\n            if (isSameType(expectedTypes[i], type)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProps(rawProps, props, instance) {\r\n    const resolvedValues = toRaw(props);\r\n    const options = instance.propsOptions[0];\r\n    for (const key in options) {\r\n        let opt = options[key];\r\n        if (opt == null)\r\n            continue;\r\n        validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProp(name, value, prop, isAbsent) {\r\n    const { type, required, validator } = prop;\r\n    // required!\r\n    if (required && isAbsent) {\r\n        warn('Missing required prop: \"' + name + '\"');\r\n        return;\r\n    }\r\n    // missing but optional\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    // type check\r\n    if (type != null && type !== true) {\r\n        let isValid = false;\r\n        const types = isArray(type) ? type : [type];\r\n        const expectedTypes = [];\r\n        // value is valid as long as one of the specified types match\r\n        for (let i = 0; i < types.length && !isValid; i++) {\r\n            const { valid, expectedType } = assertType(value, types[i]);\r\n            expectedTypes.push(expectedType || '');\r\n            isValid = valid;\r\n        }\r\n        if (!isValid) {\r\n            warn(getInvalidTypeMessage(name, value, expectedTypes));\r\n            return;\r\n        }\r\n    }\r\n    // custom validator\r\n    if (validator && !validator(value)) {\r\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\r\n    }\r\n}\r\nconst isSimpleType = /*#__PURE__*/ makeMap('String,Number,Boolean,Function,Symbol,BigInt');\r\n/**\r\n * dev only\r\n */\r\nfunction assertType(value, type) {\r\n    let valid;\r\n    const expectedType = getType(type);\r\n    if (isSimpleType(expectedType)) {\r\n        const t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = isObject(value);\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = isArray(value);\r\n    }\r\n    else {\r\n        valid = value instanceof type;\r\n    }\r\n    return {\r\n        valid,\r\n        expectedType\r\n    };\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\r\n        ` Expected ${expectedTypes.map(capitalize).join(', ')}`;\r\n    const expectedType = expectedTypes[0];\r\n    const receivedType = toRawType(value);\r\n    const expectedValue = styleValue(value, expectedType);\r\n    const receivedValue = styleValue(value, receivedType);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += ` with value ${expectedValue}`;\r\n    }\r\n    message += `, got ${receivedType} `;\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += `with value ${receivedValue}.`;\r\n    }\r\n    return message;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return `\"${value}\"`;\r\n    }\r\n    else if (type === 'Number') {\r\n        return `${Number(value)}`;\r\n    }\r\n    else {\r\n        return `${value}`;\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isExplicable(type) {\r\n    const explicitTypes = ['string', 'number', 'boolean'];\r\n    return explicitTypes.some(elem => type.toLowerCase() === elem);\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isBoolean(...args) {\r\n    return args.some(elem => elem.toLowerCase() === 'boolean');\r\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\r\n    if (target) {\r\n        const hooks = target[type] || (target[type] = []);\r\n        // cache the error handling wrapper for injected hooks so the same hook\r\n        // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\r\n        // handling\".\r\n        const wrappedHook = hook.__weh ||\r\n            (hook.__weh = (...args) => {\r\n                if (target.isUnmounted) {\r\n                    return;\r\n                }\r\n                // disable tracking inside all lifecycle hooks\r\n                // since they can potentially be called inside effects.\r\n                pauseTracking();\r\n                // Set currentInstance during hook invocation.\r\n                // This assumes the hook does not synchronously trigger other hooks, which\r\n                // can only be false when the user does something really funky.\r\n                setCurrentInstance(target);\r\n                const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n                setCurrentInstance(null);\r\n                resetTracking();\r\n                return res;\r\n            });\r\n        if (prepend) {\r\n            hooks.unshift(wrappedHook);\r\n        }\r\n        else {\r\n            hooks.push(wrappedHook);\r\n        }\r\n        return wrappedHook;\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''));\r\n        warn(`${apiName} is called when there is no active component instance to be ` +\r\n            `associated with. ` +\r\n            `Lifecycle injection APIs can only be used during execution of setup().` +\r\n            (``));\r\n    }\r\n}\r\nconst createHook = (lifecycle) => (hook, target = currentInstance) => \r\n// post-create lifecycle registrations are noops during SSR\r\n!isInSSRComponentSetup && injectHook(lifecycle, hook, target);\r\nconst onBeforeMount = createHook(\"bm\" /* BEFORE_MOUNT */);\r\nconst onMounted = createHook(\"m\" /* MOUNTED */);\r\nconst onBeforeUpdate = createHook(\"bu\" /* BEFORE_UPDATE */);\r\nconst onUpdated = createHook(\"u\" /* UPDATED */);\r\nconst onBeforeUnmount = createHook(\"bum\" /* BEFORE_UNMOUNT */);\r\nconst onUnmounted = createHook(\"um\" /* UNMOUNTED */);\r\nconst onRenderTriggered = createHook(\"rtg\" /* RENDER_TRIGGERED */);\r\nconst onRenderTracked = createHook(\"rtc\" /* RENDER_TRACKED */);\r\nconst onErrorCaptured = (hook, target = currentInstance) => {\r\n    injectHook(\"ec\" /* ERROR_CAPTURED */, hook, target);\r\n};\n\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isFunction(cb)) {\r\n        warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\r\n            `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\r\n            `supports \\`watch(source, cb, options?) signature.`);\r\n    }\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\r\n    if ((process.env.NODE_ENV !== 'production') && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */, [\r\n                    instance && instance.proxy\r\n                ]);\r\n            }\r\n            else {\r\n                (process.env.NODE_ENV !== 'production') && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */, [\r\n                instance && instance.proxy\r\n            ]);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n        (process.env.NODE_ENV !== 'production') && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    let onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\r\nfunction onActivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"a\" /* ACTIVATED */, target);\r\n}\r\nfunction onDeactivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"da\" /* DEACTIVATED */, target);\r\n}\r\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\r\n    // cache the deactivate branch check wrapper for injected hooks so the same\r\n    // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\r\n    // deactivation check\".\r\n    const wrappedHook = hook.__wdc ||\r\n        (hook.__wdc = () => {\r\n            // only fire the hook if the target instance is NOT in a deactivated branch.\r\n            let current = target;\r\n            while (current) {\r\n                if (current.isDeactivated) {\r\n                    return;\r\n                }\r\n                current = current.parent;\r\n            }\r\n            hook();\r\n        });\r\n    injectHook(type, wrappedHook, target);\r\n    // In addition to registering it on the target instance, we walk up the parent\r\n    // chain and register it on all ancestor instances that are keep-alive roots.\r\n    // This avoids the need to walk the entire component tree when invoking these\r\n    // hooks, and more importantly, avoids the need to track child components in\r\n    // arrays.\r\n    if (target) {\r\n        let current = target.parent;\r\n        while (current && current.parent) {\r\n            if (isKeepAlive(current.parent.vnode)) {\r\n                injectToKeepAliveRoot(wrappedHook, type, target, current);\r\n            }\r\n            current = current.parent;\r\n        }\r\n    }\r\n}\r\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\r\n    // injectHook wraps the original for error handling, so make sure to remove\r\n    // the wrapped version.\r\n    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\r\n    onUnmounted(() => {\r\n        remove(keepAliveRoot[type], injected);\r\n    }, target);\r\n}\n\n/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');\r\nfunction validateDirectiveName(name) {\r\n    if (isBuiltInDirective(name)) {\r\n        warn('Do not use built-in directive ids as custom directive id: ' + name);\r\n    }\r\n}\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nfunction withDirectives(vnode, directives) {\r\n    {\r\n        (process.env.NODE_ENV !== 'production') && warn(`withDirectives can only be used inside render functions.`);\r\n        return vnode;\r\n    }\r\n}\n\nfunction createAppContext() {\r\n    return {\r\n        app: null,\r\n        config: {\r\n            isNativeTag: NO,\r\n            performance: false,\r\n            globalProperties: {},\r\n            optionMergeStrategies: {},\r\n            isCustomElement: NO,\r\n            errorHandler: undefined,\r\n            warnHandler: undefined\r\n        },\r\n        mixins: [],\r\n        components: {},\r\n        directives: {},\r\n        provides: Object.create(null)\r\n    };\r\n}\r\nlet uid$1 = 0;\r\n// fixed by xxxxxx\r\nfunction createAppAPI() {\r\n    return function createApp(rootComponent, rootProps = null) {\r\n        if (rootProps != null && !isObject(rootProps)) {\r\n            (process.env.NODE_ENV !== 'production') && warn(`root props passed to app.mount() must be an object.`);\r\n            rootProps = null;\r\n        }\r\n        const context = createAppContext();\r\n        const installedPlugins = new Set();\r\n        // fixed by xxxxxx\r\n        // let isMounted = false\r\n        const app = (context.app = {\r\n            _uid: uid$1++,\r\n            _component: rootComponent,\r\n            _props: rootProps,\r\n            _container: null,\r\n            _context: context,\r\n            version,\r\n            get config() {\r\n                return context.config;\r\n            },\r\n            set config(v) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn(`app.config cannot be replaced. Modify individual options instead.`);\r\n                }\r\n            },\r\n            use(plugin, ...options) {\r\n                if (installedPlugins.has(plugin)) {\r\n                    (process.env.NODE_ENV !== 'production') && warn(`Plugin has already been applied to target app.`);\r\n                }\r\n                else if (plugin && isFunction(plugin.install)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin.install(app, ...options);\r\n                }\r\n                else if (isFunction(plugin)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin(app, ...options);\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn(`A plugin must either be a function or an object with an \"install\" ` +\r\n                        `function.`);\r\n                }\r\n                return app;\r\n            },\r\n            mixin(mixin) {\r\n                if (__VUE_OPTIONS_API__) {\r\n                    if (!context.mixins.includes(mixin)) {\r\n                        context.mixins.push(mixin);\r\n                        // window mixin with props/emits de-optimizes props/emits\r\n                        // normalization caching.\r\n                        if (mixin.props || mixin.emits) {\r\n                            context.deopt = true;\r\n                        }\r\n                    }\r\n                    else if ((process.env.NODE_ENV !== 'production')) {\r\n                        warn('Mixin has already been applied to target app' +\r\n                            (mixin.name ? `: ${mixin.name}` : ''));\r\n                    }\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn('Mixins are only available in builds supporting Options API');\r\n                }\r\n                return app;\r\n            },\r\n            component(name, component) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    validateComponentName(name, context.config);\r\n                }\r\n                if (!component) {\r\n                    return context.components[name];\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production') && context.components[name]) {\r\n                    warn(`Component \"${name}\" has already been registered in target app.`);\r\n                }\r\n                context.components[name] = component;\r\n                return app;\r\n            },\r\n            directive(name, directive) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    validateDirectiveName(name);\r\n                }\r\n                if (!directive) {\r\n                    return context.directives[name];\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production') && context.directives[name]) {\r\n                    warn(`Directive \"${name}\" has already been registered in target app.`);\r\n                }\r\n                context.directives[name] = directive;\r\n                return app;\r\n            },\r\n            // fixed by xxxxxx\r\n            mount() { },\r\n            // fixed by xxxxxx\r\n            unmount() { },\r\n            provide(key, value) {\r\n                if ((process.env.NODE_ENV !== 'production') && key in context.provides) {\r\n                    warn(`App already provides property with key \"${String(key)}\". ` +\r\n                        `It will be overwritten with the new value.`);\r\n                }\r\n                // TypeScript doesn't allow symbols as index type\r\n                // https://github.com/Microsoft/TypeScript/issues/24587\r\n                context.provides[key] = value;\r\n                return app;\r\n            }\r\n        });\r\n        return app;\r\n    };\r\n}\n\n// implementation, close to no-op\r\nfunction defineComponent(options) {\r\n    return isFunction(options) ? { setup: options, name: options.name } : options;\r\n}\n\nconst queuePostRenderEffect = queuePostFlushCb;\n\nconst isTeleport = (type) => type.__isTeleport;\n\nconst COMPONENTS = 'components';\r\nconst DIRECTIVES = 'directives';\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n/**\r\n * @private\r\n */\r\nfunction resolveDirective(name) {\r\n    return resolveAsset(DIRECTIVES, name);\r\n}\r\n// implementation\r\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\r\n    const instance = currentInstance;\r\n    if (instance) {\r\n        const Component = instance.type;\r\n        // explicit self name has highest priority\r\n        if (type === COMPONENTS) {\r\n            const selfName = getComponentName(Component);\r\n            if (selfName &&\r\n                (selfName === name ||\r\n                    selfName === camelize(name) ||\r\n                    selfName === capitalize(camelize(name)))) {\r\n                return Component;\r\n            }\r\n        }\r\n        const res = \r\n        // local registration\r\n        // check instance[type] first for components with mixin or extends.\r\n        resolve(instance[type] || Component[type], name) ||\r\n            // window registration\r\n            resolve(instance.appContext[type], name);\r\n        if (!res && maybeSelfReference) {\r\n            // fallback to implicit self-reference\r\n            return Component;\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production') && warnMissing && !res) {\r\n            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`);\r\n        }\r\n        return res;\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`resolve${capitalize(type.slice(0, -1))} ` +\r\n            `can only be used in render() or setup().`);\r\n    }\r\n}\r\nfunction resolve(registry, name) {\r\n    return (registry &&\r\n        (registry[name] ||\r\n            registry[camelize(name)] ||\r\n            registry[capitalize(camelize(name))]));\r\n}\n\nconst Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);\r\nconst Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);\r\nconst Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);\r\nSymbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);\r\nlet currentBlock = null;\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? isString(ref) || isRef(ref) || isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = ((process.env.NODE_ENV !== 'production')\r\n    ? createVNodeWithArgsTransform\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if ((process.env.NODE_ENV !== 'production') && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if ((process.env.NODE_ENV !== 'production') && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n        type = toRaw(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        slotScopeIds: null,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if ((process.env.NODE_ENV !== 'production') && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    normalizeChildren(vnode, children);\r\n    if (// avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag, children } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        slotScopeIds: vnode.slotScopeIds,\r\n        children: (process.env.NODE_ENV !== 'production') && patchFlag === -1 /* HOISTED */ && isArray(children)\r\n            ? children.map(deepCloneVNode)\r\n            : children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * Dev only, for HMR of hoisted vnodes reused in v-for\r\n * https://github.com/vitejs/vite/issues/2022\r\n */\r\nfunction deepCloneVNode(vnode) {\r\n    const cloned = cloneVNode(vnode);\r\n    if (isArray(vnode.children)) {\r\n        cloned.children = vnode.children.map(deepCloneVNode);\r\n    }\r\n    return cloned;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`provide() can only be used inside setup().`);\r\n        }\r\n    }\r\n    else {\r\n        let provides = currentInstance.provides;\r\n        // by default an instance inherits its parent's provides object\r\n        // but when it needs to provide values of its own, it creates its\r\n        // own provides object using parent provides object as prototype.\r\n        // this way in `inject` we can simply look up injections from direct\r\n        // parent and let the prototype chain do the work.\r\n        const parentProvides = currentInstance.parent && currentInstance.parent.provides;\r\n        if (parentProvides === provides) {\r\n            provides = currentInstance.provides = Object.create(parentProvides);\r\n        }\r\n        // TS doesn't allow symbol as index type\r\n        provides[key] = value;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    const instance = currentInstance || currentRenderingInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext's `provides` if the intance is at root\r\n        const provides = instance.parent == null\r\n            ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n            : instance.parent.provides;\r\n        if (provides && key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && isFunction(defaultValue)\r\n                ? defaultValue()\r\n                : defaultValue;\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`injection \"${String(key)}\" not found.`);\r\n        }\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`inject() can only be used inside setup() or functional components.`);\r\n    }\r\n}\n\nfunction createDuplicateChecker() {\r\n    const cache = Object.create(null);\r\n    return (type, key) => {\r\n        if (cache[key]) {\r\n            warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\r\n        }\r\n        else {\r\n            cache[key] = type;\r\n        }\r\n    };\r\n}\r\nlet shouldCacheAccess = true;\r\nfunction applyOptions$1(instance, options, deferredData = [], deferredWatch = [], deferredProvide = [], asMixin = false) {\r\n    const { \r\n    // composition\r\n    mixins, extends: extendsOptions, \r\n    // state\r\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n    // assets\r\n    components, directives, \r\n    // lifecycle\r\n    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, \r\n    // public API\r\n    expose } = options;\r\n    const publicThis = instance.proxy;\r\n    const ctx = instance.ctx;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (asMixin && render && instance.render === NOOP) {\r\n        instance.render = render;\r\n    }\r\n    // applyOptions is called non-as-mixin once per instance\r\n    if (!asMixin) {\r\n        shouldCacheAccess = false;\r\n        callSyncHook('beforeCreate', \"bc\" /* BEFORE_CREATE */, options, instance, globalMixins);\r\n        shouldCacheAccess = true;\r\n        // window mixins are applied first\r\n        applyMixins(instance, globalMixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    // extending a base component...\r\n    if (extendsOptions) {\r\n        applyOptions$1(instance, extendsOptions, deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n    // local mixins\r\n    if (mixins) {\r\n        applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    const checkDuplicateProperties = (process.env.NODE_ENV !== 'production') ? createDuplicateChecker() : null;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const [propsOptions] = instance.propsOptions;\r\n        if (propsOptions) {\r\n            for (const key in propsOptions) {\r\n                checkDuplicateProperties(\"Props\" /* PROPS */, key);\r\n            }\r\n        }\r\n    }\r\n    // options initialization order (to be consistent with Vue 2):\r\n    // - props (already done outside of this function)\r\n    // - inject\r\n    // - methods\r\n    // - data (deferred since it relies on `this` access)\r\n    // - computed\r\n    // - watch (deferred since it relies on `this` access)\r\n    // fixed by xxxxxx\r\n    if (!__VUE_CREATED_DEFERRED__ && injectOptions) {\r\n        if (isArray(injectOptions)) {\r\n            for (let i = 0; i < injectOptions.length; i++) {\r\n                const key = injectOptions[i];\r\n                ctx[key] = inject(key);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkDuplicateProperties(\"Inject\" /* INJECT */, key);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (const key in injectOptions) {\r\n                const opt = injectOptions[key];\r\n                if (isObject(opt)) {\r\n                    ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);\r\n                }\r\n                else {\r\n                    ctx[key] = inject(opt);\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkDuplicateProperties(\"Inject\" /* INJECT */, key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (methods) {\r\n        for (const key in methods) {\r\n            const methodHandler = methods[key];\r\n            if (isFunction(methodHandler)) {\r\n                // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,\r\n                // and those are read-only but reconfigurable, so it needs to be redefined here\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    Object.defineProperty(ctx, key, {\r\n                        value: methodHandler.bind(publicThis),\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        writable: true\r\n                    });\r\n                }\r\n                else {\r\n                    ctx[key] = methodHandler.bind(publicThis);\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkDuplicateProperties(\"Methods\" /* METHODS */, key);\r\n                }\r\n            }\r\n            else if ((process.env.NODE_ENV !== 'production')) {\r\n                warn(`Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` +\r\n                    `Did you reference the function correctly?`);\r\n            }\r\n        }\r\n    }\r\n    if (!asMixin) {\r\n        if (deferredData.length) {\r\n            deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));\r\n        }\r\n        if (dataOptions) {\r\n            // @ts-ignore dataOptions is not fully type safe\r\n            resolveData(instance, dataOptions, publicThis);\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const rawData = toRaw(instance.data);\r\n            for (const key in rawData) {\r\n                checkDuplicateProperties(\"Data\" /* DATA */, key);\r\n                // expose data on ctx during dev\r\n                if (key[0] !== '$' && key[0] !== '_') {\r\n                    Object.defineProperty(ctx, key, {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        get: () => rawData[key],\r\n                        set: NOOP\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (dataOptions) {\r\n        deferredData.push(dataOptions);\r\n    }\r\n    if (computedOptions) {\r\n        for (const key in computedOptions) {\r\n            const opt = computedOptions[key];\r\n            const get = isFunction(opt)\r\n                ? opt.bind(publicThis, publicThis)\r\n                : isFunction(opt.get)\r\n                    ? opt.get.bind(publicThis, publicThis)\r\n                    : NOOP;\r\n            if ((process.env.NODE_ENV !== 'production') && get === NOOP) {\r\n                warn(`Computed property \"${key}\" has no getter.`);\r\n            }\r\n            const set = !isFunction(opt) && isFunction(opt.set)\r\n                ? opt.set.bind(publicThis)\r\n                : (process.env.NODE_ENV !== 'production')\r\n                    ? () => {\r\n                        warn(`Write operation failed: computed property \"${key}\" is readonly.`);\r\n                    }\r\n                    : NOOP;\r\n            const c = computed$1({\r\n                get,\r\n                set\r\n            });\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => c.value,\r\n                set: v => (c.value = v)\r\n            });\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkDuplicateProperties(\"Computed\" /* COMPUTED */, key);\r\n            }\r\n        }\r\n    }\r\n    if (watchOptions) {\r\n        deferredWatch.push(watchOptions);\r\n    }\r\n    if (!asMixin && deferredWatch.length) {\r\n        deferredWatch.forEach(watchOptions => {\r\n            for (const key in watchOptions) {\r\n                createWatcher(watchOptions[key], ctx, publicThis, key);\r\n            }\r\n        });\r\n    }\r\n    // fixed by xxxxxx\r\n    if (!__VUE_CREATED_DEFERRED__) {\r\n        if (provideOptions) {\r\n            deferredProvide.push(provideOptions);\r\n        }\r\n        if (!asMixin && deferredProvide.length) {\r\n            deferredProvide.forEach(provideOptions => {\r\n                const provides = isFunction(provideOptions)\r\n                    ? provideOptions.call(publicThis)\r\n                    : provideOptions;\r\n                Reflect.ownKeys(provides).forEach(key => {\r\n                    provide(key, provides[key]);\r\n                });\r\n            });\r\n        }\r\n    }\r\n    // asset options.\r\n    // To reduce memory usage, only components with mixins or extends will have\r\n    // resolved asset registry attached to instance.\r\n    if (asMixin) {\r\n        if (components) {\r\n            extend(instance.components ||\r\n                (instance.components = extend({}, instance.type.components)), components);\r\n        }\r\n        if (directives) {\r\n            extend(instance.directives ||\r\n                (instance.directives = extend({}, instance.type.directives)), directives);\r\n        }\r\n    }\r\n    // fixed by xxxxxx\r\n    // lifecycle options\r\n    if (__VUE_CREATED_DEFERRED__) {\r\n        ctx.$callSyncHook = function (name) {\r\n            return callSyncHook(name, \"c\" /* CREATED */, options, instance, globalMixins);\r\n        };\r\n    }\r\n    else if (!asMixin) {\r\n        callSyncHook('created', \"c\" /* CREATED */, options, instance, globalMixins);\r\n    }\r\n    if (beforeMount) {\r\n        onBeforeMount(beforeMount.bind(publicThis));\r\n    }\r\n    if (mounted) {\r\n        onMounted(mounted.bind(publicThis));\r\n    }\r\n    if (beforeUpdate) {\r\n        onBeforeUpdate(beforeUpdate.bind(publicThis));\r\n    }\r\n    if (updated) {\r\n        onUpdated(updated.bind(publicThis));\r\n    }\r\n    if (activated) {\r\n        onActivated(activated.bind(publicThis));\r\n    }\r\n    if (deactivated) {\r\n        onDeactivated(deactivated.bind(publicThis));\r\n    }\r\n    if (errorCaptured) {\r\n        onErrorCaptured(errorCaptured.bind(publicThis));\r\n    }\r\n    if (renderTracked) {\r\n        onRenderTracked(renderTracked.bind(publicThis));\r\n    }\r\n    if (renderTriggered) {\r\n        onRenderTriggered(renderTriggered.bind(publicThis));\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production') && beforeDestroy) {\r\n        warn(`\\`beforeDestroy\\` has been renamed to \\`beforeUnmount\\`.`);\r\n    }\r\n    if (beforeUnmount) {\r\n        onBeforeUnmount(beforeUnmount.bind(publicThis));\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production') && destroyed) {\r\n        warn(`\\`destroyed\\` has been renamed to \\`unmounted\\`.`);\r\n    }\r\n    if (unmounted) {\r\n        onUnmounted(unmounted.bind(publicThis));\r\n    }\r\n    if (isArray(expose)) {\r\n        if (!asMixin) {\r\n            if (expose.length) {\r\n                const exposed = instance.exposed || (instance.exposed = proxyRefs({}));\r\n                expose.forEach(key => {\r\n                    exposed[key] = toRef(publicThis, key);\r\n                });\r\n            }\r\n            else if (!instance.exposed) {\r\n                instance.exposed = EMPTY_OBJ;\r\n            }\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`The \\`expose\\` option is ignored when used in mixins.`);\r\n        }\r\n    }\r\n    // fixed by xxxxxx\r\n    if (instance.ctx.$onApplyOptions) {\r\n        instance.ctx.$onApplyOptions(options, instance, publicThis);\r\n    }\r\n}\r\nfunction callSyncHook(name, type, options, instance, globalMixins) {\r\n    for (let i = 0; i < globalMixins.length; i++) {\r\n        callHookWithMixinAndExtends(name, type, globalMixins[i], instance);\r\n    }\r\n    callHookWithMixinAndExtends(name, type, options, instance);\r\n}\r\nfunction callHookWithMixinAndExtends(name, type, options, instance) {\r\n    const { extends: base, mixins } = options;\r\n    const selfHook = options[name];\r\n    if (base) {\r\n        callHookWithMixinAndExtends(name, type, base, instance);\r\n    }\r\n    if (mixins) {\r\n        for (let i = 0; i < mixins.length; i++) {\r\n            callHookWithMixinAndExtends(name, type, mixins[i], instance);\r\n        }\r\n    }\r\n    if (selfHook) {\r\n        callWithAsyncErrorHandling(selfHook.bind(instance.proxy), instance, type);\r\n    }\r\n}\r\nfunction applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        applyOptions$1(instance, mixins[i], deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n}\r\nfunction resolveData(instance, dataFn, publicThis) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isFunction(dataFn)) {\r\n        warn(`The data option must be a function. ` +\r\n            `Plain object usage is no longer supported.`);\r\n    }\r\n    shouldCacheAccess = false;\r\n    const data = dataFn.call(publicThis, publicThis);\r\n    shouldCacheAccess = true;\r\n    if ((process.env.NODE_ENV !== 'production') && isPromise(data)) {\r\n        warn(`data() returned a Promise - note data() cannot be async; If you ` +\r\n            `intend to perform data fetching before component renders, use ` +\r\n            `async setup() + <Suspense>.`);\r\n    }\r\n    if (!isObject(data)) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`data() should return an object.`);\r\n    }\r\n    else if (instance.data === EMPTY_OBJ) {\r\n        instance.data = reactive(data);\r\n    }\r\n    else {\r\n        // existing data: this is a mixin or extends.\r\n        extend(instance.data, data);\r\n    }\r\n}\r\nfunction createWatcher(raw, ctx, publicThis, key) {\r\n    const getter = key.includes('.')\r\n        ? createPathGetter(publicThis, key)\r\n        : () => publicThis[key];\r\n    if (isString(raw)) {\r\n        const handler = ctx[raw];\r\n        if (isFunction(handler)) {\r\n            watch(getter, handler);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Invalid watch handler specified by key \"${raw}\"`, handler);\r\n        }\r\n    }\r\n    else if (isFunction(raw)) {\r\n        watch(getter, raw.bind(publicThis));\r\n    }\r\n    else if (isObject(raw)) {\r\n        if (isArray(raw)) {\r\n            raw.forEach(r => createWatcher(r, ctx, publicThis, key));\r\n        }\r\n        else {\r\n            const handler = isFunction(raw.handler)\r\n                ? raw.handler.bind(publicThis)\r\n                : ctx[raw.handler];\r\n            if (isFunction(handler)) {\r\n                watch(getter, handler, raw);\r\n            }\r\n            else if ((process.env.NODE_ENV !== 'production')) {\r\n                warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\r\n            }\r\n        }\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`Invalid watch option: \"${key}\"`, raw);\r\n    }\r\n}\r\nfunction createPathGetter(ctx, path) {\r\n    const segments = path.split('.');\r\n    return () => {\r\n        let cur = ctx;\r\n        for (let i = 0; i < segments.length && cur; i++) {\r\n            cur = cur[segments[i]];\r\n        }\r\n        return cur;\r\n    };\r\n}\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => {\r\n    if (!i)\r\n        return null;\r\n    if (isStatefulComponent(i))\r\n        return i.exposed ? i.exposed : i.proxy;\r\n    return getPublicInstance(i.parent);\r\n};\r\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    // $nextTick: i => nextTick.bind(i.proxy!), // fixed by xxxxxx\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if ((process.env.NODE_ENV !== 'production') && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                (process.env.NODE_ENV !== 'production') && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // window properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production') &&\r\n            currentRenderingInstance &&\r\n            (!isString(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== EMPTY_OBJ &&\r\n                (key[0] === '$' || key[0] === '_') &&\r\n                hasOwn(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else if (instance === currentRenderingInstance) {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (hasOwn(instance.props, key)) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production') && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n            hasOwn(ctx, key) ||\r\n            hasOwn(publicPropertiesMap, key) ||\r\n            hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif ((process.env.NODE_ENV !== 'production') && !false) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if ((process.env.NODE_ENV !== 'production') && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\n// In dev mode, the proxy target exposes the same properties as seen on `this`\r\n// for easier console inspection. In prod mode it will be an empty object so\r\n// these properties definitions can be skipped.\r\nfunction createRenderContext(instance) {\r\n    const target = {};\r\n    // expose internal instance for proxy handlers\r\n    Object.defineProperty(target, `_`, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        get: () => instance\r\n    });\r\n    // expose public properties\r\n    Object.keys(publicPropertiesMap).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => publicPropertiesMap[key](instance),\r\n            // intercepted by the proxy so no need for implementation,\r\n            // but needed to prevent set errors\r\n            set: NOOP\r\n        });\r\n    });\r\n    // expose window properties\r\n    const { globalProperties } = instance.appContext.config;\r\n    Object.keys(globalProperties).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => globalProperties[key],\r\n            set: NOOP\r\n        });\r\n    });\r\n    return target;\r\n}\r\n// dev only\r\nfunction exposePropsOnRenderContext(instance) {\r\n    const { ctx, propsOptions: [propsOptions] } = instance;\r\n    if (propsOptions) {\r\n        Object.keys(propsOptions).forEach(key => {\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => instance.props[key],\r\n                set: NOOP\r\n            });\r\n        });\r\n    }\r\n}\r\n// dev only\r\nfunction exposeSetupStateOnRenderContext(instance) {\r\n    const { ctx, setupState } = instance;\r\n    Object.keys(toRaw(setupState)).forEach(key => {\r\n        if (key[0] === '$' || key[0] === '_') {\r\n            warn(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` +\r\n                `which are reserved prefixes for Vue internals.`);\r\n            return;\r\n        }\r\n        Object.defineProperty(ctx, key, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => setupState[key],\r\n            set: NOOP\r\n        });\r\n    });\r\n}\n\nconst emptyAppContext = createAppContext();\r\nlet uid$2 = 0;\r\nfunction createComponentInstance(vnode, parent, suspense) {\r\n    const type = vnode.type;\r\n    // inherit parent app context - or - if root, adopt from root vnode\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n    const instance = {\r\n        uid: uid$2++,\r\n        vnode,\r\n        type,\r\n        parent,\r\n        appContext,\r\n        root: null,\r\n        next: null,\r\n        subTree: null,\r\n        update: null,\r\n        render: null,\r\n        proxy: null,\r\n        exposed: null,\r\n        withProxy: null,\r\n        effects: null,\r\n        provides: parent ? parent.provides : Object.create(appContext.provides),\r\n        accessCache: null,\r\n        renderCache: [],\r\n        // local resovled assets\r\n        components: null,\r\n        directives: null,\r\n        // resolved props and emits options\r\n        propsOptions: normalizePropsOptions(type, appContext),\r\n        emitsOptions: normalizeEmitsOptions(type, appContext),\r\n        // emit\r\n        emit: null,\r\n        emitted: null,\r\n        // props default value\r\n        propsDefaults: EMPTY_OBJ,\r\n        // state\r\n        ctx: EMPTY_OBJ,\r\n        data: EMPTY_OBJ,\r\n        props: EMPTY_OBJ,\r\n        attrs: EMPTY_OBJ,\r\n        slots: EMPTY_OBJ,\r\n        refs: EMPTY_OBJ,\r\n        setupState: EMPTY_OBJ,\r\n        setupContext: null,\r\n        // suspense related\r\n        suspense,\r\n        suspenseId: suspense ? suspense.pendingId : 0,\r\n        asyncDep: null,\r\n        asyncResolved: false,\r\n        // lifecycle hooks\r\n        // not using enums here because it results in computed properties\r\n        isMounted: false,\r\n        isUnmounted: false,\r\n        isDeactivated: false,\r\n        bc: null,\r\n        c: null,\r\n        bm: null,\r\n        m: null,\r\n        bu: null,\r\n        u: null,\r\n        um: null,\r\n        bum: null,\r\n        da: null,\r\n        a: null,\r\n        rtg: null,\r\n        rtc: null,\r\n        ec: null\r\n    };\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        instance.ctx = createRenderContext(instance);\r\n    }\r\n    else {\r\n        instance.ctx = { _: instance };\r\n    }\r\n    instance.root = parent ? parent.root : instance;\r\n    instance.emit = emit.bind(null, instance);\r\n    return instance;\r\n}\r\nlet currentInstance = null;\r\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\r\nconst setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n};\r\nconst isBuiltInTag = /*#__PURE__*/ makeMap('slot,component');\r\nfunction validateComponentName(name, config) {\r\n    const appIsNativeTag = config.isNativeTag || NO;\r\n    if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n        warn('Do not use built-in or reserved HTML elements as component id: ' + name);\r\n    }\r\n}\r\nfunction isStatefulComponent(instance) {\r\n    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n}\r\nlet isInSSRComponentSetup = false;\r\nfunction setupComponent(instance, isSSR = false) {\r\n    isInSSRComponentSetup = isSSR;\r\n    const { props /*, children*/ } = instance.vnode;\r\n    const isStateful = isStatefulComponent(instance);\r\n    initProps(instance, props, isStateful, isSSR);\r\n    // initSlots(instance, children) // fixed by xxxxxx\r\n    const setupResult = isStateful\r\n        ? setupStatefulComponent(instance, isSSR)\r\n        : undefined;\r\n    isInSSRComponentSetup = false;\r\n    return setupResult;\r\n}\r\nfunction setupStatefulComponent(instance, isSSR) {\r\n    const Component = instance.type;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        if (Component.name) {\r\n            validateComponentName(Component.name, instance.appContext.config);\r\n        }\r\n        if (Component.components) {\r\n            const names = Object.keys(Component.components);\r\n            for (let i = 0; i < names.length; i++) {\r\n                validateComponentName(names[i], instance.appContext.config);\r\n            }\r\n        }\r\n        if (Component.directives) {\r\n            const names = Object.keys(Component.directives);\r\n            for (let i = 0; i < names.length; i++) {\r\n                validateDirectiveName(names[i]);\r\n            }\r\n        }\r\n    }\r\n    // 0. create render proxy property access cache\r\n    instance.accessCache = Object.create(null);\r\n    // 1. create public instance / render proxy\r\n    // also mark it raw so it's never observed\r\n    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        exposePropsOnRenderContext(instance);\r\n    }\r\n    // 2. call setup()\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        const setupContext = (instance.setupContext =\r\n            setup.length > 1 ? createSetupContext(instance) : null);\r\n        currentInstance = instance;\r\n        pauseTracking();\r\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [(process.env.NODE_ENV !== 'production') ? shallowReadonly(instance.props) : instance.props, setupContext]);\r\n        resetTracking();\r\n        currentInstance = null;\r\n        if (isPromise(setupResult)) {\r\n            if (isSSR) {\r\n                // return the promise so server-renderer can wait on it\r\n                return setupResult\r\n                    .then((resolvedResult) => {\r\n                    handleSetupResult(instance, resolvedResult, isSSR);\r\n                })\r\n                    .catch(e => {\r\n                    handleError(e, instance, 0 /* SETUP_FUNCTION */);\r\n                });\r\n            }\r\n            else if ((process.env.NODE_ENV !== 'production')) {\r\n                warn(`setup() returned a Promise, but the version of Vue you are using ` +\r\n                    `does not support it yet.`);\r\n            }\r\n        }\r\n        else {\r\n            handleSetupResult(instance, setupResult, isSSR);\r\n        }\r\n    }\r\n    else {\r\n        finishComponentSetup(instance, isSSR);\r\n    }\r\n}\r\nfunction handleSetupResult(instance, setupResult, isSSR) {\r\n    if (isFunction(setupResult)) {\r\n        // setup returned an inline render function\r\n        {\r\n            instance.render = setupResult;\r\n        }\r\n    }\r\n    else if (isObject(setupResult)) {\r\n        if ((process.env.NODE_ENV !== 'production') && isVNode(setupResult)) {\r\n            warn(`setup() should not return VNodes directly - ` +\r\n                `return a render function instead.`);\r\n        }\r\n        // setup returned bindings.\r\n        // assuming a render function compiled from template is present.\r\n        if ((process.env.NODE_ENV !== 'production') || false) {\r\n            instance.devtoolsRawSetupState = setupResult;\r\n        }\r\n        instance.setupState = proxyRefs(setupResult);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            exposeSetupStateOnRenderContext(instance);\r\n        }\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production') && setupResult !== undefined) {\r\n        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\r\n    }\r\n    finishComponentSetup(instance, isSSR);\r\n}\r\nfunction finishComponentSetup(instance, isSSR) {\r\n    const Component = instance.type;\r\n    // template / render function normalization\r\n    if (!instance.render) {\r\n        instance.render = (Component.render || NOOP);\r\n        // for runtime-compiled render functions using `with` blocks, the render\r\n        // proxy used needs a different `has` handler which is more performant and\r\n        // also only allows a whitelist of globals to fallthrough.\r\n        if (instance.render._rc) {\r\n            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\r\n        }\r\n    }\r\n    // support for 2.x options\r\n    if (__VUE_OPTIONS_API__) {\r\n        currentInstance = instance;\r\n        pauseTracking();\r\n        applyOptions$1(instance, Component);\r\n        resetTracking();\r\n        currentInstance = null;\r\n    }\r\n    // warn missing template/render\r\n    // the runtime compilation of template in SSR is done by server-render\r\n    if ((process.env.NODE_ENV !== 'production') && !Component.render && instance.render === NOOP && !isSSR) {\r\n        /* istanbul ignore if */\r\n        if (Component.template) {\r\n            warn(`Component provided template option but ` +\r\n                `runtime compilation is not supported in this build of Vue.` +\r\n                (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\r\n                    ) /* should not happen */);\r\n        }\r\n        else {\r\n            warn(`Component is missing template or render function.`);\r\n        }\r\n    }\r\n}\r\nconst attrHandlers = {\r\n    get: (target, key) => {\r\n        if ((process.env.NODE_ENV !== 'production')) ;\r\n        return target[key];\r\n    },\r\n    set: () => {\r\n        warn(`setupContext.attrs is readonly.`);\r\n        return false;\r\n    },\r\n    deleteProperty: () => {\r\n        warn(`setupContext.attrs is readonly.`);\r\n        return false;\r\n    }\r\n};\r\nfunction createSetupContext(instance) {\r\n    const expose = exposed => {\r\n        if ((process.env.NODE_ENV !== 'production') && instance.exposed) {\r\n            warn(`expose() should be called only once per setup().`);\r\n        }\r\n        instance.exposed = proxyRefs(exposed);\r\n    };\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        // We use getters in dev in case libs like test-utils overwrite instance\r\n        // properties (overwrites should not be done in prod)\r\n        return Object.freeze({\r\n            get attrs() {\r\n                return new Proxy(instance.attrs, attrHandlers);\r\n            },\r\n            get slots() {\r\n                return shallowReadonly(instance.slots);\r\n            },\r\n            get emit() {\r\n                return (event, ...args) => instance.emit(event, ...args);\r\n            },\r\n            expose\r\n        });\r\n    }\r\n    else {\r\n        return {\r\n            attrs: instance.attrs,\r\n            slots: instance.slots,\r\n            emit: instance.emit,\r\n            expose\r\n        };\r\n    }\r\n}\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\nfunction getComponentName(Component) {\r\n    return isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = getComponentName(Component);\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nfunction computed$1(getterOrOptions) {\r\n    const c = computed(getterOrOptions);\r\n    recordInstanceBoundEffect(c.effect);\r\n    return c;\r\n}\n\n// implementation\r\nfunction defineProps() {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`defineProps() is a compiler-hint helper that is only usable inside ` +\r\n            `<script setup> of a single file component. Its arguments should be ` +\r\n            `compiled away and passing it at runtime has no effect.`);\r\n    }\r\n    return null;\r\n}\r\n// implementation\r\nfunction defineEmit() {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`defineEmit() is a compiler-hint helper that is only usable inside ` +\r\n            `<script setup> of a single file component. Its arguments should be ` +\r\n            `compiled away and passing it at runtime has no effect.`);\r\n    }\r\n    return null;\r\n}\n\n// Core API ------------------------------------------------------------------\r\nconst version = \"3.0.9\";\n\n// import deepCopy from './deepCopy'\r\n/**\r\n * https://raw.githubusercontent.com/Tencent/westore/master/packages/westore/utils/diff.js\r\n */\r\nconst ARRAYTYPE = '[object Array]';\r\nconst OBJECTTYPE = '[object Object]';\r\n// const FUNCTIONTYPE = '[object Function]'\r\nfunction diff(current, pre) {\r\n    const result = {};\r\n    syncKeys(current, pre);\r\n    _diff(current, pre, '', result);\r\n    return result;\r\n}\r\nfunction syncKeys(current, pre) {\r\n    current = unref(current);\r\n    if (current === pre)\r\n        return;\r\n    const rootCurrentType = toTypeString(current);\r\n    const rootPreType = toTypeString(pre);\r\n    if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {\r\n        for (let key in pre) {\r\n            const currentValue = current[key];\r\n            if (currentValue === undefined) {\r\n                current[key] = null;\r\n            }\r\n            else {\r\n                syncKeys(currentValue, pre[key]);\r\n            }\r\n        }\r\n    }\r\n    else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {\r\n        if (current.length >= pre.length) {\r\n            pre.forEach((item, index) => {\r\n                syncKeys(current[index], item);\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction _diff(current, pre, path, result) {\r\n    current = unref(current);\r\n    if (current === pre)\r\n        return;\r\n    const rootCurrentType = toTypeString(current);\r\n    const rootPreType = toTypeString(pre);\r\n    if (rootCurrentType == OBJECTTYPE) {\r\n        if (rootPreType != OBJECTTYPE ||\r\n            Object.keys(current).length < Object.keys(pre).length) {\r\n            setResult(result, path, current);\r\n        }\r\n        else {\r\n            for (let key in current) {\r\n                const currentValue = unref(current[key]);\r\n                const preValue = pre[key];\r\n                const currentType = toTypeString(currentValue);\r\n                const preType = toTypeString(preValue);\r\n                if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {\r\n                    if (currentValue != preValue) {\r\n                        setResult(result, (path == '' ? '' : path + '.') + key, currentValue);\r\n                    }\r\n                }\r\n                else if (currentType == ARRAYTYPE) {\r\n                    if (preType != ARRAYTYPE) {\r\n                        setResult(result, (path == '' ? '' : path + '.') + key, currentValue);\r\n                    }\r\n                    else {\r\n                        if (currentValue.length < preValue.length) {\r\n                            setResult(result, (path == '' ? '' : path + '.') + key, currentValue);\r\n                        }\r\n                        else {\r\n                            currentValue.forEach((item, index) => {\r\n                                _diff(item, preValue[index], (path == '' ? '' : path + '.') + key + '[' + index + ']', result);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                else if (currentType == OBJECTTYPE) {\r\n                    if (preType != OBJECTTYPE ||\r\n                        Object.keys(currentValue).length < Object.keys(preValue).length) {\r\n                        setResult(result, (path == '' ? '' : path + '.') + key, currentValue);\r\n                    }\r\n                    else {\r\n                        for (let subKey in currentValue) {\r\n                            _diff(currentValue[subKey], preValue[subKey], (path == '' ? '' : path + '.') + key + '.' + subKey, result);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (rootCurrentType == ARRAYTYPE) {\r\n        if (rootPreType != ARRAYTYPE) {\r\n            setResult(result, path, current);\r\n        }\r\n        else {\r\n            if (current.length < pre.length) {\r\n                setResult(result, path, current);\r\n            }\r\n            else {\r\n                current.forEach((item, index) => {\r\n                    _diff(item, pre[index], path + '[' + index + ']', result);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        setResult(result, path, current);\r\n    }\r\n}\r\nfunction setResult(result, k, v) {\r\n    result[k] = v; //deepCopy(v)\r\n}\n\nfunction hasComponentEffect(instance) {\r\n    return queue.includes(instance.update);\r\n}\r\nfunction flushCallbacks(instance) {\r\n    const ctx = instance.ctx;\r\n    const callbacks = ctx.__next_tick_callbacks;\r\n    if (callbacks && callbacks.length) {\r\n        if (process.env.VUE_APP_DEBUG) {\r\n            const mpInstance = ctx.$scope;\r\n            console.log('[' +\r\n                +new Date() +\r\n                '][' +\r\n                (mpInstance.is || mpInstance.route) +\r\n                '][' +\r\n                instance.uid +\r\n                ']:flushCallbacks[' +\r\n                callbacks.length +\r\n                ']');\r\n        }\r\n        const copies = callbacks.slice(0);\r\n        callbacks.length = 0;\r\n        for (let i = 0; i < copies.length; i++) {\r\n            copies[i]();\r\n        }\r\n    }\r\n}\r\nfunction nextTick$1(instance, fn) {\r\n    const ctx = instance.ctx;\r\n    if (!ctx.__next_tick_pending && !hasComponentEffect(instance)) {\r\n        if (process.env.VUE_APP_DEBUG) {\r\n            const mpInstance = ctx.$scope;\r\n            console.log('[' +\r\n                +new Date() +\r\n                '][' +\r\n                (mpInstance.is || mpInstance.route) +\r\n                '][' +\r\n                instance.uid +\r\n                ']:nextVueTick');\r\n        }\r\n        return nextTick(fn && fn.bind(instance.proxy));\r\n    }\r\n    if (process.env.VUE_APP_DEBUG) {\r\n        const mpInstance = ctx.$scope;\r\n        console.log('[' +\r\n            +new Date() +\r\n            '][' +\r\n            (mpInstance.is || mpInstance.route) +\r\n            '][' +\r\n            instance.uid +\r\n            ']:nextMPTick');\r\n    }\r\n    let _resolve;\r\n    if (!ctx.__next_tick_callbacks) {\r\n        ctx.__next_tick_callbacks = [];\r\n    }\r\n    ctx.__next_tick_callbacks.push(() => {\r\n        if (fn) {\r\n            callWithErrorHandling(fn.bind(instance.proxy), instance, 14 /* SCHEDULER */);\r\n        }\r\n        else if (_resolve) {\r\n            _resolve(instance.proxy);\r\n        }\r\n    });\r\n    return new Promise(resolve => {\r\n        _resolve = resolve;\r\n    });\r\n}\n\nfunction getMPInstanceData(instance, keys) {\r\n    const data = instance.data;\r\n    const ret = Object.create(null);\r\n    //仅同步 data 中有的数据\r\n    keys.forEach(key => {\r\n        ret[key] = data[key];\r\n    });\r\n    return ret;\r\n}\r\nfunction getVueInstanceData(instance) {\r\n    const { data, setupState, ctx } = instance;\r\n    const keys = new Set();\r\n    const ret = Object.create(null);\r\n    Object.keys(setupState).forEach(key => {\r\n        keys.add(key);\r\n        ret[key] = setupState[key];\r\n    });\r\n    if (data) {\r\n        Object.keys(data).forEach(key => {\r\n            if (!keys.has(key)) {\r\n                keys.add(key);\r\n                ret[key] = data[key];\r\n            }\r\n        });\r\n    }\r\n    if (__VUE_OPTIONS_API__) {\r\n        if (ctx.$computedKeys) {\r\n            ctx.$computedKeys.forEach((key) => {\r\n                if (!keys.has(key)) {\r\n                    keys.add(key);\r\n                    ret[key] = ctx[key];\r\n                }\r\n            });\r\n        }\r\n    }\r\n    if (ctx.$mp) {\r\n        // TODO\r\n        extend(ret, ctx.$mp.data || {});\r\n    }\r\n    // TODO form-field\r\n    // track\r\n    return { keys, data: JSON.parse(JSON.stringify(ret)) };\r\n}\r\nfunction patch(instance) {\r\n    const ctx = instance.ctx;\r\n    const mpType = ctx.mpType;\r\n    if (mpType === 'page' || mpType === 'component') {\r\n        const start = Date.now();\r\n        const mpInstance = ctx.$scope;\r\n        const { keys, data } = getVueInstanceData(instance);\r\n        // data.__webviewId__ = mpInstance.data.__webviewId__\r\n        const diffData = diff(data, getMPInstanceData(mpInstance, keys));\r\n        if (Object.keys(diffData).length) {\r\n            if (process.env.VUE_APP_DEBUG) {\r\n                console.log('[' +\r\n                    +new Date() +\r\n                    '][' +\r\n                    (mpInstance.is || mpInstance.route) +\r\n                    '][' +\r\n                    instance.uid +\r\n                    '][耗时' +\r\n                    (Date.now() - start) +\r\n                    ']差量更新', JSON.stringify(diffData));\r\n            }\r\n            ctx.__next_tick_pending = true;\r\n            mpInstance.setData(diffData, () => {\r\n                ctx.__next_tick_pending = false;\r\n                flushCallbacks(instance);\r\n            });\r\n            // props update may have triggered pre-flush watchers.\r\n            flushPreFlushCbs(undefined, instance.update);\r\n        }\r\n        else {\r\n            flushCallbacks(instance);\r\n        }\r\n    }\r\n}\n\nfunction initAppConfig(appConfig) {\r\n    appConfig.globalProperties.$nextTick = function $nextTick(fn) {\r\n        return nextTick$1(this.$, fn);\r\n    };\r\n}\n\nfunction onApplyOptions(options, instance, publicThis) {\r\n    instance.appContext.config.globalProperties.$applyOptions(options, instance, publicThis);\r\n    const computedOptions = options.computed;\r\n    if (computedOptions) {\r\n        const keys = Object.keys(computedOptions);\r\n        if (keys.length) {\r\n            const ctx = instance.ctx;\r\n            if (!ctx.$computedKeys) {\r\n                ctx.$computedKeys = [];\r\n            }\r\n            ctx.$computedKeys.push(...keys);\r\n        }\r\n    }\r\n    // remove\r\n    delete instance.ctx.$onApplyOptions;\r\n}\n\nvar MPType;\r\n(function (MPType) {\r\n    MPType[\"APP\"] = \"app\";\r\n    MPType[\"PAGE\"] = \"page\";\r\n    MPType[\"COMPONENT\"] = \"component\";\r\n})(MPType || (MPType = {}));\r\nconst queuePostRenderEffect$1 = queuePostFlushCb;\r\nfunction mountComponent(initialVNode, options) {\r\n    const instance = (initialVNode.component = createComponentInstance(initialVNode, options.parentComponent, null));\r\n    if (__VUE_OPTIONS_API__) {\r\n        instance.ctx.$onApplyOptions = onApplyOptions;\r\n        instance.ctx.$children = [];\r\n    }\r\n    if (options.mpType === 'app') {\r\n        instance.render = NOOP;\r\n    }\r\n    if (options.onBeforeSetup) {\r\n        options.onBeforeSetup(instance, options);\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        pushWarningContext(initialVNode);\r\n    }\r\n    setupComponent(instance);\r\n    if (__VUE_OPTIONS_API__) {\r\n        // $children\r\n        if (options.parentComponent && instance.proxy) {\r\n            options.parentComponent.ctx\r\n                .$children.push(instance.proxy);\r\n        }\r\n    }\r\n    setupRenderEffect(instance);\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        popWarningContext();\r\n    }\r\n    return instance.proxy;\r\n}\r\nconst prodEffectOptions = {\r\n    scheduler: queueJob\r\n};\r\nfunction createDevEffectOptions(instance) {\r\n    return {\r\n        scheduler: queueJob,\r\n        onTrack: instance.rtc ? e => invokeArrayFns$1(instance.rtc, e) : void 0,\r\n        onTrigger: instance.rtg ? e => invokeArrayFns$1(instance.rtg, e) : void 0\r\n    };\r\n}\r\nfunction setupRenderEffect(instance) {\r\n    // create reactive effect for rendering\r\n    instance.update = effect(function componentEffect() {\r\n        if (!instance.isMounted) {\r\n            instance.render && instance.render.call(instance.proxy);\r\n            patch(instance);\r\n        }\r\n        else {\r\n            instance.render && instance.render.call(instance.proxy);\r\n            // updateComponent\r\n            const { bu, u } = instance;\r\n            // beforeUpdate hook\r\n            if (bu) {\r\n                invokeArrayFns$1(bu);\r\n            }\r\n            patch(instance);\r\n            // updated hook\r\n            if (u) {\r\n                queuePostRenderEffect$1(u);\r\n            }\r\n        }\r\n    }, (process.env.NODE_ENV !== 'production') ? createDevEffectOptions(instance) : prodEffectOptions);\r\n}\r\nfunction unmountComponent(instance) {\r\n    const { bum, effects, update, um } = instance;\r\n    // beforeUnmount hook\r\n    if (bum) {\r\n        invokeArrayFns$1(bum);\r\n    }\r\n    if (effects) {\r\n        for (let i = 0; i < effects.length; i++) {\r\n            stop(effects[i]);\r\n        }\r\n    }\r\n    // update may be null if a component is unmounted before its async\r\n    // setup has resolved.\r\n    if (update) {\r\n        stop(update);\r\n    }\r\n    // unmounted hook\r\n    if (um) {\r\n        queuePostRenderEffect$1(um);\r\n    }\r\n    queuePostRenderEffect$1(() => {\r\n        instance.isUnmounted = true;\r\n    });\r\n}\r\nconst oldCreateApp = createAppAPI();\r\nfunction createVueApp(rootComponent, rootProps = null) {\r\n    const app = oldCreateApp(rootComponent, rootProps);\r\n    const appContext = app._context;\r\n    initAppConfig(appContext.config);\r\n    const createVNode = initialVNode => {\r\n        initialVNode.appContext = appContext;\r\n        initialVNode.shapeFlag = 6 /* COMPONENT */;\r\n        return initialVNode;\r\n    };\r\n    const createComponent = function createComponent(initialVNode, options) {\r\n        return mountComponent(createVNode(initialVNode), options);\r\n    };\r\n    const destroyComponent = function destroyComponent(component) {\r\n        return component && unmountComponent(component.$);\r\n    };\r\n    app.mount = function mount() {\r\n        rootComponent.render = NOOP;\r\n        const instance = mountComponent(createVNode({ type: rootComponent }), {\r\n            mpType: MPType.APP,\r\n            mpInstance: null,\r\n            parentComponent: null,\r\n            slots: [],\r\n            props: null\r\n        });\r\n        instance.$app = app;\r\n        instance.$createComponent = createComponent;\r\n        instance.$destroyComponent = destroyComponent;\r\n        appContext.$appInstance = instance;\r\n        return instance;\r\n    };\r\n    app.unmount = function unmount() {\r\n        warn(`Cannot unmount an app.`);\r\n    };\r\n    return app;\r\n}\n\nfunction withModifiers() { }\r\nfunction createVNode$1() { }\n\nfunction applyOptions(options, instance, publicThis) {\r\n    const mpType = options.mpType || publicThis.$mpType;\r\n    if (!mpType) {\r\n        // 仅 App,Page 类型支持 on 生命周期\r\n        return;\r\n    }\r\n    Object.keys(options).forEach((name) => {\r\n        if (name.indexOf('on') === 0) {\r\n            const hook = options[name];\r\n            if (isFunction(hook)) {\r\n                injectHook(name, hook.bind(publicThis), instance);\r\n            }\r\n        }\r\n    });\r\n}\n\nfunction set(target, key, val) {\r\n    return (target[key] = val);\r\n}\r\nfunction hasHook(name) {\r\n    const hooks = this.$[name];\r\n    if (hooks && hooks.length) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction callHook(name, args) {\r\n    const hooks = this.$[name];\r\n    return hooks && invokeArrayFns(hooks, args);\r\n}\n\nfunction errorHandler(err, instance, info) {\r\n    if (!instance) {\r\n        throw err;\r\n    }\r\n    const app = getApp();\r\n    if (!app || !app.$vm) {\r\n        throw err;\r\n    }\r\n    {\r\n        app.$vm.$callHook(ON_ERROR, err, info);\r\n    }\r\n}\n\nfunction b64DecodeUnicode(str) {\r\n    return decodeURIComponent(atob(str)\r\n        .split('')\r\n        .map(function (c) {\r\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\r\n    })\r\n        .join(''));\r\n}\r\nfunction getCurrentUserInfo() {\r\n    const token = uni.getStorageSync('uni_id_token') || '';\r\n    const tokenArr = token.split('.');\r\n    if (!token || tokenArr.length !== 3) {\r\n        return {\r\n            uid: null,\r\n            role: [],\r\n            permission: [],\r\n            tokenExpired: 0,\r\n        };\r\n    }\r\n    let userInfo;\r\n    try {\r\n        userInfo = JSON.parse(b64DecodeUnicode(tokenArr[1]));\r\n    }\r\n    catch (error) {\r\n        throw new Error('获取当前用户信息出错，详细错误信息为：' + error.message);\r\n    }\r\n    userInfo.tokenExpired = userInfo.exp * 1000;\r\n    delete userInfo.exp;\r\n    delete userInfo.iat;\r\n    return userInfo;\r\n}\r\nfunction uniIdMixin(globalProperties) {\r\n    globalProperties.uniIDHasRole = function (roleId) {\r\n        const { role } = getCurrentUserInfo();\r\n        return role.indexOf(roleId) > -1;\r\n    };\r\n    globalProperties.uniIDHasPermission = function (permissionId) {\r\n        const { permission } = getCurrentUserInfo();\r\n        return this.uniIDHasRole('admin') || permission.indexOf(permissionId) > -1;\r\n    };\r\n    globalProperties.uniIDTokenValid = function () {\r\n        const { tokenExpired } = getCurrentUserInfo();\r\n        return tokenExpired > Date.now();\r\n    };\r\n}\n\nfunction initApp(app) {\r\n    const appConfig = app._context.config;\r\n    if (isFunction(app._component.onError)) {\r\n        appConfig.errorHandler = errorHandler;\r\n    }\r\n    const globalProperties = appConfig.globalProperties;\r\n    uniIdMixin(globalProperties);\r\n    {\r\n        // 小程序，待重构，不再挂靠全局\r\n        globalProperties.$hasHook = hasHook;\r\n        globalProperties.$callHook = callHook;\r\n    }\r\n    if (__VUE_OPTIONS_API__) {\r\n        globalProperties.$set = set;\r\n        globalProperties.$applyOptions = applyOptions;\r\n    }\r\n}\n\nvar plugin = {\r\n    install(app) {\r\n        initApp(app);\r\n        const globalProperties = app._context.config.globalProperties;\r\n        const oldCallHook = globalProperties.$callHook;\r\n        globalProperties.$callHook = function callHook(name, args) {\r\n            if (name === 'mounted') {\r\n                oldCallHook.call(this, 'bm'); // beforeMount\r\n                this.$.isMounted = true;\r\n                name = 'm';\r\n            }\r\n            return oldCallHook.call(this, name, args);\r\n        };\r\n        const oldMount = app.mount;\r\n        app.mount = function mount(rootContainer) {\r\n            const instance = oldMount.call(app, rootContainer);\r\n            // @ts-ignore\r\n            createMiniProgramApp(instance);\r\n            return instance;\r\n        };\r\n    },\r\n};\n\nfunction createApp(rootComponent, rootProps = null) {\r\n    rootComponent && (rootComponent.mpType = 'app');\r\n    return createVueApp(rootComponent, rootProps).use(plugin);\r\n}\r\nconst createSSRApp = createApp;\n\nexport { callWithAsyncErrorHandling, callWithErrorHandling, computed$1 as computed, createApp, createSSRApp, createVNode$1 as createVNode, createVueApp, customRef, defineComponent, defineEmit, defineProps, getCurrentInstance, inject, injectHook, isInSSRComponentSetup, isProxy, isReactive, isReadonly, isRef, logError, markRaw, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, provide, reactive, readonly, ref, resolveDirective, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, version, warn, watch, watchEffect, withDirectives, withModifiers };\n","import { isArray, isPromise, isFunction, isPlainObject, hasOwn, isString } from '@vue/shared';\n\nconst API_TYPE_SYNC = 1;\nfunction validateProtocol(_name, _args, _protocol) {\n    return true;\n}\nfunction formatApiArgs(args, options) {\n    if (!options) {\n        return args;\n    }\n}\nfunction createApi({ type, name, options }, fn, protocol) {\n    return function (...args) {\n        if (type === API_TYPE_SYNC) {\n            if (!((process.env.NODE_ENV !== 'production') && protocol && !validateProtocol())) {\n                return fn.apply(null, formatApiArgs(args, options));\n            }\n        }\n    };\n}\n\nconst Upx2pxProtocol = [\n    {\n        name: 'upx',\n        type: [Number, String],\n        required: true\n    }\n];\n\nconst EPS = 1e-4;\nconst BASE_DEVICE_WIDTH = 750;\nlet isIOS = false;\nlet deviceWidth = 0;\nlet deviceDPR = 0;\nfunction checkDeviceWidth() {\n    const { platform, pixelRatio, windowWidth } = wx.getSystemInfoSync();\n    deviceWidth = windowWidth;\n    deviceDPR = pixelRatio;\n    isIOS = platform === 'ios';\n}\nconst upx2px = createApi({ type: API_TYPE_SYNC, name: 'upx2px' }, (number, newDeviceWidth) => {\n    if (deviceWidth === 0) {\n        checkDeviceWidth();\n    }\n    number = Number(number);\n    if (number === 0) {\n        return 0;\n    }\n    let result = (number / BASE_DEVICE_WIDTH) * (newDeviceWidth || deviceWidth);\n    if (result < 0) {\n        result = -result;\n    }\n    result = Math.floor(result + EPS);\n    if (result === 0) {\n        if (deviceDPR === 1 || !isIOS) {\n            result = 1;\n        }\n        else {\n            result = 0.5;\n        }\n    }\n    return number < 0 ? -result : result;\n}, Upx2pxProtocol);\n\nvar HOOKS;\n(function (HOOKS) {\n    HOOKS[\"INVOKE\"] = \"invoke\";\n    HOOKS[\"SUCCESS\"] = \"success\";\n    HOOKS[\"FAIL\"] = \"fail\";\n    HOOKS[\"COMPLETE\"] = \"complete\";\n    HOOKS[\"RETURN_VALUE\"] = \"returnValue\";\n})(HOOKS || (HOOKS = {}));\nconst globalInterceptors = {};\nconst scopedInterceptors = {};\nfunction wrapperHook(hook) {\n    return function (data) {\n        return hook(data) || data;\n    };\n}\nfunction queue(hooks, data) {\n    let promise = false;\n    for (let i = 0; i < hooks.length; i++) {\n        const hook = hooks[i];\n        if (promise) {\n            promise = Promise.resolve(wrapperHook(hook));\n        }\n        else {\n            const res = hook(data);\n            if (isPromise(res)) {\n                promise = Promise.resolve(res);\n            }\n            if (res === false) {\n                return {\n                    then() { },\n                    catch() { }\n                };\n            }\n        }\n    }\n    return (promise || {\n        then(callback) {\n            return callback(data);\n        },\n        catch() { }\n    });\n}\nfunction wrapperOptions(interceptors, options = {}) {\n    [HOOKS.SUCCESS, HOOKS.FAIL, HOOKS.COMPLETE].forEach(name => {\n        const hooks = interceptors[name];\n        if (!isArray(hooks)) {\n            return;\n        }\n        const oldCallback = options[name];\n        options[name] = function callbackInterceptor(res) {\n            queue(hooks, res).then((res) => {\n                return (isFunction(oldCallback) && oldCallback(res)) || res;\n            });\n        };\n    });\n    return options;\n}\nfunction wrapperReturnValue(method, returnValue) {\n    const returnValueHooks = [];\n    if (isArray(globalInterceptors.returnValue)) {\n        returnValueHooks.push(...globalInterceptors.returnValue);\n    }\n    const interceptor = scopedInterceptors[method];\n    if (interceptor && isArray(interceptor.returnValue)) {\n        returnValueHooks.push(...interceptor.returnValue);\n    }\n    returnValueHooks.forEach(hook => {\n        returnValue = hook(returnValue) || returnValue;\n    });\n    return returnValue;\n}\nfunction getApiInterceptorHooks(method) {\n    const interceptor = Object.create(null);\n    Object.keys(globalInterceptors).forEach(hook => {\n        if (hook !== 'returnValue') {\n            interceptor[hook] = globalInterceptors[hook].slice();\n        }\n    });\n    const scopedInterceptor = scopedInterceptors[method];\n    if (scopedInterceptor) {\n        Object.keys(scopedInterceptor).forEach(hook => {\n            if (hook !== 'returnValue') {\n                interceptor[hook] = (interceptor[hook] || []).concat(scopedInterceptor[hook]);\n            }\n        });\n    }\n    return interceptor;\n}\nfunction invokeApi(method, api, options, ...params) {\n    const interceptor = getApiInterceptorHooks(method);\n    if (interceptor && Object.keys(interceptor).length) {\n        if (isArray(interceptor.invoke)) {\n            const res = queue(interceptor.invoke, options);\n            return res.then(options => {\n                return api(wrapperOptions(interceptor, options), ...params);\n            });\n        }\n        else {\n            return api(wrapperOptions(interceptor, options), ...params);\n        }\n    }\n    return api(options, ...params);\n}\n\nconst AddInterceptorProtocol = [\n    {\n        name: 'method',\n        type: [String, Object],\n        required: true\n    }\n];\nconst RemoveInterceptorProtocol = AddInterceptorProtocol;\n\nfunction mergeInterceptorHook(interceptors, interceptor) {\n    Object.keys(interceptor).forEach(hook => {\n        if (isFunction(interceptor[hook])) {\n            interceptors[hook] = mergeHook(interceptors[hook], interceptor[hook]);\n        }\n    });\n}\nfunction removeInterceptorHook(interceptors, interceptor) {\n    if (!interceptors || !interceptor) {\n        return;\n    }\n    Object.keys(interceptor).forEach(hook => {\n        if (isFunction(interceptor[hook])) {\n            removeHook(interceptors[hook], interceptor[hook]);\n        }\n    });\n}\nfunction mergeHook(parentVal, childVal) {\n    const res = childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : isArray(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n    return res ? dedupeHooks(res) : res;\n}\nfunction dedupeHooks(hooks) {\n    const res = [];\n    for (let i = 0; i < hooks.length; i++) {\n        if (res.indexOf(hooks[i]) === -1) {\n            res.push(hooks[i]);\n        }\n    }\n    return res;\n}\nfunction removeHook(hooks, hook) {\n    if (!hooks) {\n        return;\n    }\n    const index = hooks.indexOf(hook);\n    if (index !== -1) {\n        hooks.splice(index, 1);\n    }\n}\nconst addInterceptor = createApi({ type: API_TYPE_SYNC, name: 'addInterceptor' }, (method, interceptor) => {\n    if (typeof method === 'string' && isPlainObject(interceptor)) {\n        mergeInterceptorHook(scopedInterceptors[method] || (scopedInterceptors[method] = {}), interceptor);\n    }\n    else if (isPlainObject(method)) {\n        mergeInterceptorHook(globalInterceptors, method);\n    }\n}, AddInterceptorProtocol);\nconst removeInterceptor = createApi({ type: API_TYPE_SYNC, name: 'removeInterceptor' }, (method, interceptor) => {\n    if (typeof method === 'string') {\n        if (isPlainObject(interceptor)) {\n            removeInterceptorHook(scopedInterceptors[method], interceptor);\n        }\n        else {\n            delete scopedInterceptors[method];\n        }\n    }\n    else if (isPlainObject(method)) {\n        removeInterceptorHook(globalInterceptors, method);\n    }\n}, RemoveInterceptorProtocol);\n\nconst SYNC_API_RE = /^\\$|sendNativeEvent|restoreGlobal|getCurrentSubNVue|getMenuButtonBoundingClientRect|^report|interceptors|Interceptor$|getSubNVueById|requireNativePlugin|upx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64/;\nconst CONTEXT_API_RE = /^create|Manager$/;\n// Context例外情况\nconst CONTEXT_API_RE_EXC = ['createBLEConnection'];\n// 同步例外情况\nconst ASYNC_API = ['createBLEConnection'];\nconst CALLBACK_API_RE = /^on|^off/;\nfunction isContextApi(name) {\n    return CONTEXT_API_RE.test(name) && CONTEXT_API_RE_EXC.indexOf(name) === -1;\n}\nfunction isSyncApi(name) {\n    return SYNC_API_RE.test(name) && ASYNC_API.indexOf(name) === -1;\n}\nfunction isCallbackApi(name) {\n    return CALLBACK_API_RE.test(name) && name !== 'onPush';\n}\nfunction handlePromise(promise) {\n    if (!__UNI_PROMISE_API__) {\n        return promise;\n    }\n    return promise\n        .then(data => {\n        return [null, data];\n    })\n        .catch(err => [err]);\n}\nfunction shouldPromise(name) {\n    if (isContextApi(name) || isSyncApi(name) || isCallbackApi(name)) {\n        return false;\n    }\n    return true;\n}\n/* eslint-disable no-extend-native */\nif (!Promise.prototype.finally) {\n    Promise.prototype.finally = function (onfinally) {\n        const promise = this.constructor;\n        return this.then(value => promise.resolve(onfinally && onfinally()).then(() => value), reason => promise.resolve(onfinally && onfinally()).then(() => {\n            throw reason;\n        }));\n    };\n}\nfunction promisify(name, api) {\n    if (!shouldPromise(name)) {\n        return api;\n    }\n    if (!isFunction(api)) {\n        return api;\n    }\n    return function promiseApi(options = {}, ...params) {\n        if (isFunction(options.success) ||\n            isFunction(options.fail) ||\n            isFunction(options.complete)) {\n            return wrapperReturnValue(name, invokeApi(name, api, options, ...params));\n        }\n        return wrapperReturnValue(name, handlePromise(new Promise((resolve, reject) => {\n            invokeApi(name, api, Object.assign({}, options, {\n                success: resolve,\n                fail: reject\n            }), ...params);\n        })));\n    };\n}\n\nconst CALLBACKS = ['success', 'fail', 'cancel', 'complete'];\nfunction initWrapper(protocols) {\n    function processCallback(methodName, method, returnValue) {\n        return function (res) {\n            return method(processReturnValue(methodName, res, returnValue));\n        };\n    }\n    function processArgs(methodName, fromArgs, argsOption = {}, returnValue = {}, keepFromArgs = false) {\n        if (isPlainObject(fromArgs)) {\n            // 一般 api 的参数解析\n            const toArgs = (keepFromArgs === true ? fromArgs : {}); // returnValue 为 false 时，说明是格式化返回值，直接在返回值对象上修改赋值\n            if (isFunction(argsOption)) {\n                argsOption = argsOption(fromArgs, toArgs) || {};\n            }\n            for (const key in fromArgs) {\n                if (hasOwn(argsOption, key)) {\n                    let keyOption = argsOption[key];\n                    if (isFunction(keyOption)) {\n                        keyOption = keyOption(fromArgs[key], fromArgs, toArgs);\n                    }\n                    if (!keyOption) {\n                        // 不支持的参数\n                        console.warn(`微信小程序 ${methodName} 暂不支持 ${key}`);\n                    }\n                    else if (isString(keyOption)) {\n                        // 重写参数 key\n                        toArgs[keyOption] = fromArgs[key];\n                    }\n                    else if (isPlainObject(keyOption)) {\n                        // {name:newName,value:value}可重新指定参数 key:value\n                        toArgs[keyOption.name ? keyOption.name : key] = keyOption.value;\n                    }\n                }\n                else if (CALLBACKS.indexOf(key) !== -1) {\n                    const callback = fromArgs[key];\n                    if (isFunction(callback)) {\n                        toArgs[key] = processCallback(methodName, callback, returnValue);\n                    }\n                }\n                else {\n                    if (!keepFromArgs && !hasOwn(toArgs, key)) {\n                        toArgs[key] = fromArgs[key];\n                    }\n                }\n            }\n            return toArgs;\n        }\n        else if (isFunction(fromArgs)) {\n            fromArgs = processCallback(methodName, fromArgs, returnValue);\n        }\n        return fromArgs;\n    }\n    function processReturnValue(methodName, res, returnValue, keepReturnValue = false) {\n        if (isFunction(protocols.returnValue)) {\n            // 处理通用 returnValue\n            res = protocols.returnValue(methodName, res);\n        }\n        return processArgs(methodName, res, returnValue, {}, keepReturnValue);\n    }\n    return function wrapper(methodName, method) {\n        if (!hasOwn(protocols, methodName)) {\n            return method;\n        }\n        const protocol = protocols[methodName];\n        if (!protocol) {\n            // 暂不支持的 api\n            return function () {\n                console.error(`微信小程序 暂不支持${methodName}`);\n            };\n        }\n        return function (arg1, arg2) {\n            // 目前 api 最多两个参数\n            let options = protocol;\n            if (isFunction(protocol)) {\n                options = protocol(arg1);\n            }\n            arg1 = processArgs(methodName, arg1, options.args, options.returnValue);\n            const args = [arg1];\n            if (typeof arg2 !== 'undefined') {\n                args.push(arg2);\n            }\n            const returnValue = wx[options.name || methodName].apply(wx, args);\n            if (isSyncApi(methodName)) {\n                // 同步 api\n                return processReturnValue(methodName, returnValue, options.returnValue, isContextApi(methodName));\n            }\n            return returnValue;\n        };\n    };\n}\n\nconst baseApis = { upx2px, addInterceptor, removeInterceptor };\nfunction initUni(api, protocols) {\n    const wrapper = initWrapper(protocols);\n    const UniProxyHandlers = {\n        get(target, key) {\n            if (hasOwn(target, key)) {\n                return target[key];\n            }\n            if (hasOwn(api, key)) {\n                return promisify(key, api[key]);\n            }\n            if (hasOwn(baseApis, key)) {\n                return promisify(key, baseApis[key]);\n            }\n            // event-api\n            // provider-api?\n            return promisify(key, wrapper(key, wx[key]));\n        }\n    };\n    return new Proxy({}, UniProxyHandlers);\n}\n\nfunction initGetProvider(providers) {\n    return function getProvider({ service, success, fail, complete }) {\n        let res;\n        if (providers[service]) {\n            res = {\n                errMsg: 'getProvider:ok',\n                service,\n                provider: providers[service]\n            };\n            isFunction(success) && success(res);\n        }\n        else {\n            res = {\n                errMsg: 'getProvider:fail:服务[' + service + ']不存在'\n            };\n            isFunction(fail) && fail(res);\n        }\n        isFunction(complete) && complete(res);\n    };\n}\n\nconst previewImage = {\n    args(fromArgs, toArgs) {\n        let currentIndex = parseInt(fromArgs.current);\n        if (isNaN(currentIndex)) {\n            return;\n        }\n        const urls = fromArgs.urls;\n        if (!isArray(urls)) {\n            return;\n        }\n        const len = urls.length;\n        if (!len) {\n            return;\n        }\n        if (currentIndex < 0) {\n            currentIndex = 0;\n        }\n        else if (currentIndex >= len) {\n            currentIndex = len - 1;\n        }\n        if (currentIndex > 0) {\n            toArgs.current = urls[currentIndex];\n            toArgs.urls = urls.filter((item, index) => index < currentIndex ? item !== urls[currentIndex] : true);\n        }\n        else {\n            toArgs.current = urls[0];\n        }\n        return {\n            indicator: false,\n            loop: false\n        };\n    }\n};\nfunction addSafeAreaInsets(fromRes, toRes) {\n    if (fromRes.safeArea) {\n        const safeArea = fromRes.safeArea;\n        toRes.safeAreaInsets = {\n            top: safeArea.top,\n            left: safeArea.left,\n            right: fromRes.windowWidth - safeArea.right,\n            bottom: fromRes.windowHeight - safeArea.bottom\n        };\n    }\n}\nconst getSystemInfo = {\n    returnValue: addSafeAreaInsets\n};\nconst getSystemInfoSync = getSystemInfo;\nconst redirectTo = {};\nconst createCanvasContext = {\n    returnValue(fromRes, toRes) {\n        const measureText = fromRes.measureText;\n        toRes.measureText = function (text, callback) {\n            const textMetrics = measureText.call(this, text);\n            if (typeof callback === 'function') {\n                setTimeout(() => callback(textMetrics), 0);\n            }\n            return textMetrics;\n        };\n    }\n};\n\nconst getProvider = initGetProvider({\n    oauth: ['weixin'],\n    share: ['weixin'],\n    payment: ['wxpay'],\n    push: ['weixin']\n});\n\nvar shims = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getProvider: getProvider\n});\n\nvar protocols = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  redirectTo: redirectTo,\n  previewImage: previewImage,\n  getSystemInfo: getSystemInfo,\n  getSystemInfoSync: getSystemInfoSync,\n  createCanvasContext: createCanvasContext\n});\n\nvar index = initUni(shims, protocols);\n\nexport default index;\n","/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    // Split the content into individual lines but capture the newline sequence\r\n    // that separated each line. This is important because the actual sequence is\r\n    // needed to properly take into account the full line length for offset\r\n    // comparison\r\n    let lines = source.split(/(\\r?\\n)/);\r\n    // Separate the lines and newline sequences into separate arrays for easier referencing\r\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\r\n    lines = lines.filter((_, idx) => idx % 2 === 0);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count +=\r\n            lines[i].length +\r\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - (lineLength + newLineSeqLength));\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + newLineSeqLength;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.substring(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isObject(val)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nconst babelParserDefaultPlugins = [\r\n    'bigInt',\r\n    'optionalChaining',\r\n    'nullishCoalescingOperator'\r\n];\r\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => val instanceof Date;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, babelParserDefaultPlugins, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, invokeArrayFns, isArray, isBooleanAttr, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownAttr, isMap, isModelListener, isNoUnitNumericStyleProp, isObject, isOn, isPlainObject, isPromise, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, makeMap, normalizeClass, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { isArray, hasOwn, toNumber, isPlainObject, isObject, isFunction, extend, NOOP, camelize } from '@vue/shared';\n\nfunction setModel(target, key, value, modifiers) {\n    if (isArray(modifiers)) {\n        if (modifiers.indexOf('trim') !== -1) {\n            value = value.trim();\n        }\n        if (modifiers.indexOf('number') !== -1) {\n            value = toNumber(value);\n        }\n    }\n    if (!target) {\n        target = this;\n    }\n    target[key] = value;\n}\nfunction setSync(target, key, value) {\n    if (!target) {\n        target = this;\n    }\n    target[key] = value;\n}\nfunction getOrig(data) {\n    if (isPlainObject(data)) {\n        return data.$orig || data;\n    }\n    return data;\n}\nfunction map(val, iteratee) {\n    let ret, i, l, keys, key;\n    if (isArray(val)) {\n        ret = new Array(val.length);\n        for (i = 0, l = val.length; i < l; i++) {\n            ret[i] = iteratee(val[i], i);\n        }\n        return ret;\n    }\n    else if (isObject(val)) {\n        keys = Object.keys(val);\n        ret = Object.create(null);\n        for (i = 0, l = keys.length; i < l; i++) {\n            key = keys[i];\n            ret[key] = iteratee(val[key], key, i);\n        }\n        return ret;\n    }\n    return [];\n}\nconst MP_METHODS = [\n    'createSelectorQuery',\n    'createIntersectionObserver',\n    'selectAllComponents',\n    'selectComponent'\n];\nfunction createEmitFn(oldEmit, ctx) {\n    return function emit(event, ...args) {\n        if (ctx.$scope && event) {\n            ctx.$scope.triggerEvent(event, { __args__: args });\n        }\n        return oldEmit.apply(this, [event, ...args]);\n    };\n}\nfunction initBaseInstance(instance, options) {\n    const ctx = instance.ctx;\n    // mp\n    ctx.mpType = options.mpType; // @deprecated\n    ctx.$mpType = options.mpType;\n    ctx.$scope = options.mpInstance;\n    // TODO @deprecated\n    ctx.$mp = {};\n    if (__VUE_OPTIONS_API__) {\n        ctx._self = {};\n    }\n    // $vm\n    ctx.$scope.$vm = instance.proxy;\n    // slots\n    {\n        instance.slots = {};\n        if (isArray(options.slots) && options.slots.length) {\n            options.slots.forEach(name => {\n                instance.slots[name] = true;\n            });\n        }\n    }\n    // $emit\n    instance.emit = createEmitFn(instance.emit, ctx);\n}\nfunction initComponentInstance(instance, options) {\n    initBaseInstance(instance, options);\n    const ctx = instance.ctx;\n    MP_METHODS.forEach(method => {\n        ctx[method] = function (...args) {\n            const mpInstance = ctx.$scope;\n            if (mpInstance && mpInstance[method]) {\n                return mpInstance[method].apply(mpInstance, args);\n            }\n        };\n    });\n    // TODO other\n    ctx.__set_model = setModel;\n    ctx.__set_sync = setSync;\n    ctx.__get_orig = getOrig;\n    // TODO\n    // ctx.__get_style = getStyle\n    ctx.__map = map;\n}\nfunction initMocks(instance, mpInstance, mocks) {\n    const ctx = instance.ctx;\n    mocks.forEach(mock => {\n        if (hasOwn(mpInstance, mock)) {\n            ctx[mock] = mpInstance[mock];\n        }\n    });\n}\n\nconst PAGE_HOOKS = [\n    'onLoad',\n    'onShow',\n    // 'onReady', // lifetimes.ready\n    'onHide',\n    'onUnload',\n    'onResize',\n    // 'onPageScroll', // 影响性能，开发者手动注册\n    'onTabItemTap',\n    'onReachBottom',\n    'onPullDownRefresh',\n    // 'onShareTimeline', // 右上角菜单，开发者手动注册\n    'onAddToFavorites'\n    // 'onShareAppMessage' // 右上角菜单，开发者手动注册\n];\nfunction findHooks(vueOptions, hooks = new Set()) {\n    if (vueOptions) {\n        Object.keys(vueOptions).forEach(name => {\n            if (name.indexOf('on') === 0 && isFunction(vueOptions[name])) {\n                hooks.add(name);\n            }\n        });\n        if (__VUE_OPTIONS_API__) {\n            const { extends: extendsOptions, mixins } = vueOptions;\n            if (mixins) {\n                mixins.forEach(mixin => findHooks(mixin, hooks));\n            }\n            if (extendsOptions) {\n                findHooks(extendsOptions, hooks);\n            }\n        }\n    }\n    return hooks;\n}\nfunction initHook(mpOptions, hook, excludes) {\n    if (excludes.indexOf(hook) === -1 && !hasOwn(mpOptions, hook)) {\n        mpOptions[hook] = function (args) {\n            return this.$vm && this.$vm.$callHook(hook, args);\n        };\n    }\n}\nconst EXCLUDE_HOOKS = ['onReady'];\nfunction initHooks(mpOptions, hooks, excludes = EXCLUDE_HOOKS) {\n    hooks.forEach(hook => initHook(mpOptions, hook, excludes));\n}\nfunction initUnknownHooks(mpOptions, vueOptions, excludes = EXCLUDE_HOOKS) {\n    findHooks(vueOptions).forEach(hook => initHook(mpOptions, hook, excludes));\n}\n\nconst HOOKS = [\n    'onShow',\n    'onHide',\n    'onError',\n    'onThemeChange',\n    'onPageNotFound',\n    'onUnhandledRejection'\n];\nfunction parseApp(instance, parseAppOptions) {\n    const internalInstance = instance.$;\n    const appOptions = {\n        globalData: (instance.$options && instance.$options.globalData) || {},\n        $vm: instance,\n        onLaunch(options) {\n            const ctx = internalInstance.ctx;\n            if (this.$vm && ctx.$scope) {\n                // 已经初始化过了，主要是为了百度，百度 onShow 在 onLaunch 之前\n                return;\n            }\n            initBaseInstance(internalInstance, {\n                mpType: 'app',\n                mpInstance: this,\n                slots: []\n            });\n            ctx.globalData = this.globalData;\n            instance.$callHook('onLaunch', options);\n        }\n    };\n    const vueOptions = instance.$.type;\n    initHooks(appOptions, HOOKS);\n    initUnknownHooks(appOptions, vueOptions);\n    if (__VUE_OPTIONS_API__) {\n        const methods = vueOptions.methods;\n        methods && extend(appOptions, methods);\n    }\n    if (parseAppOptions) {\n        parseAppOptions.parse(appOptions);\n    }\n    return appOptions;\n}\nfunction initCreateApp(parseAppOptions) {\n    return function createApp(vm) {\n        return App(parseApp(vm, parseAppOptions));\n    };\n}\n\nconst encode = encodeURIComponent;\nfunction stringifyQuery(obj, encodeStr = encode) {\n    const res = obj\n        ? Object.keys(obj)\n            .map(key => {\n            let val = obj[key];\n            if (typeof val === undefined || val === null) {\n                val = '';\n            }\n            else if (isPlainObject(val)) {\n                val = JSON.stringify(val);\n            }\n            return encodeStr(key) + '=' + encodeStr(val);\n        })\n            .filter(x => x.length > 0)\n            .join('&')\n        : null;\n    return res ? `?${res}` : '';\n}\n\nfunction initBehavior(options) {\n    return Behavior(options);\n}\nfunction initVueIds(vueIds, mpInstance) {\n    if (!vueIds) {\n        return;\n    }\n    const ids = vueIds.split(',');\n    const len = ids.length;\n    if (len === 1) {\n        mpInstance._$vueId = ids[0];\n    }\n    else if (len === 2) {\n        mpInstance._$vueId = ids[0];\n        mpInstance._$vuePid = ids[1];\n    }\n}\nconst EXTRAS = ['externalClasses'];\nfunction initExtraOptions(miniProgramComponentOptions, vueOptions) {\n    EXTRAS.forEach(name => {\n        if (hasOwn(vueOptions, name)) {\n            miniProgramComponentOptions[name] = vueOptions[name];\n        }\n    });\n}\nfunction initWxsCallMethods(methods, wxsCallMethods) {\n    if (!isArray(wxsCallMethods)) {\n        return;\n    }\n    wxsCallMethods.forEach((callMethod) => {\n        methods[callMethod] = function (args) {\n            return this.$vm[callMethod](args);\n        };\n    });\n}\nfunction initRefs(instance, mpInstance) {\n    Object.defineProperty(instance, 'refs', {\n        get() {\n            const $refs = {};\n            const components = mpInstance.selectAllComponents('.vue-ref');\n            components.forEach(component => {\n                const ref = component.dataset.ref;\n                $refs[ref] = component.$vm || component;\n            });\n            const forComponents = mpInstance.selectAllComponents('.vue-ref-in-for');\n            forComponents.forEach(component => {\n                const ref = component.dataset.ref;\n                if (!$refs[ref]) {\n                    $refs[ref] = [];\n                }\n                $refs[ref].push(component.$vm || component);\n            });\n            return $refs;\n        }\n    });\n}\nfunction findVmByVueId(instance, vuePid) {\n    // TODO vue3 中 没有 $children\n    const $children = instance.$children;\n    // 优先查找直属(反向查找:https://github.com/dcloudio/uni-app/issues/1200)\n    for (let i = $children.length - 1; i >= 0; i--) {\n        const childVm = $children[i];\n        if (childVm.$scope._$vueId === vuePid) {\n            return childVm;\n        }\n    }\n    // 反向递归查找\n    let parentVm;\n    for (let i = $children.length - 1; i >= 0; i--) {\n        parentVm = findVmByVueId($children[i], vuePid);\n        if (parentVm) {\n            return parentVm;\n        }\n    }\n}\n\nconst PROP_TYPES = [String, Number, Boolean, Object, Array, null];\nfunction createObserver(name) {\n    return function observer(newVal) {\n        if (this.$vm) {\n            this.$vm.$.props[name] = newVal; // 为了触发其他非 render watcher\n        }\n    };\n}\nfunction parsePropType(key, type, defaultValue) {\n    // [String]=>String\n    if (isArray(type) && type.length === 1) {\n        return type[0];\n    }\n    return type;\n}\nfunction initDefaultProps(isBehavior = false) {\n    const properties = {};\n    if (!isBehavior) {\n        properties.vueId = {\n            type: String,\n            value: ''\n        };\n        // 小程序不能直接定义 $slots 的 props，所以通过 vueSlots 转换到 $slots\n        properties.vueSlots = {\n            type: null,\n            value: [],\n            observer: function (newVal) {\n                const $slots = Object.create(null);\n                newVal.forEach((slotName) => {\n                    $slots[slotName] = true;\n                });\n                this.setData({\n                    $slots\n                });\n            }\n        };\n    }\n    return properties;\n}\nfunction createProperty(key, prop) {\n    prop.observer = createObserver(key);\n    return prop;\n}\nfunction initProps(mpComponentOptions, rawProps, isBehavior = false) {\n    const properties = initDefaultProps(isBehavior);\n    if (isArray(rawProps)) {\n        rawProps.forEach(key => {\n            properties[key] = createProperty(key, {\n                type: null\n            });\n        });\n    }\n    else if (isPlainObject(rawProps)) {\n        Object.keys(rawProps).forEach(key => {\n            const opts = rawProps[key];\n            if (isPlainObject(opts)) {\n                // title:{type:String,default:''}\n                let value = opts.default;\n                if (isFunction(value)) {\n                    value = value();\n                }\n                const type = opts.type;\n                opts.type = parsePropType(key, type);\n                properties[key] = createProperty(key, {\n                    type: PROP_TYPES.indexOf(type) !== -1 ? type : null,\n                    value\n                });\n            }\n            else {\n                // content:String\n                const type = parsePropType(key, opts);\n                properties[key] = createProperty(key, {\n                    type: PROP_TYPES.indexOf(type) !== -1 ? type : null\n                });\n            }\n        });\n    }\n    mpComponentOptions.properties = properties;\n}\n\nfunction initData(vueOptions) {\n    let data = vueOptions.data || {};\n    if (typeof data === 'function') {\n        try {\n            const appConfig = getApp().$vm.$.appContext\n                .config;\n            data = data.call(appConfig.globalProperties);\n        }\n        catch (e) {\n            if (process.env.VUE_APP_DEBUG) {\n                console.warn('根据 Vue 的 data 函数初始化小程序 data 失败，请尽量确保 data 函数中不访问 vm 对象，否则可能影响首次数据渲染速度。', data, e);\n            }\n        }\n    }\n    else {\n        try {\n            // 对 data 格式化\n            data = JSON.parse(JSON.stringify(data));\n        }\n        catch (e) { }\n    }\n    if (!isPlainObject(data)) {\n        data = {};\n    }\n    return data;\n}\nfunction initBehaviors(vueOptions, initBehavior) {\n    const vueBehaviors = vueOptions.behaviors;\n    const vueExtends = vueOptions.extends;\n    const vueMixins = vueOptions.mixins;\n    let vueProps = vueOptions.props;\n    if (!vueProps) {\n        vueOptions.props = vueProps = [];\n    }\n    const behaviors = [];\n    if (isArray(vueBehaviors)) {\n        vueBehaviors.forEach(behavior => {\n            behaviors.push(behavior.replace('uni://', `${__PLATFORM_PREFIX__}://`));\n            if (behavior === 'uni://form-field') {\n                if (isArray(vueProps)) {\n                    vueProps.push('name');\n                    vueProps.push('value');\n                }\n                else {\n                    vueProps.name = {\n                        type: String,\n                        default: ''\n                    };\n                    vueProps.value = {\n                        type: [String, Number, Boolean, Array, Object, Date],\n                        default: ''\n                    };\n                }\n            }\n        });\n    }\n    if (isPlainObject(vueExtends) && vueExtends.props) {\n        const behavior = {};\n        initProps(behavior, vueExtends.props, true);\n        behaviors.push(initBehavior(behavior));\n    }\n    if (isArray(vueMixins)) {\n        vueMixins.forEach(vueMixin => {\n            if (isPlainObject(vueMixin) && vueMixin.props) {\n                const behavior = {};\n                initProps(behavior, vueMixin.props, true);\n                behaviors.push(initBehavior(behavior));\n            }\n        });\n    }\n    return behaviors;\n}\nfunction applyOptions(componentOptions, vueOptions, initBehavior) {\n    componentOptions.data = initData(vueOptions);\n    componentOptions.behaviors = initBehaviors(vueOptions, initBehavior);\n}\n\nfunction getValue(obj, path) {\n    const parts = path.split('.');\n    let key = parts[0];\n    if (key.indexOf('__$n') === 0) {\n        //number index\n        key = parseInt(key.replace('__$n', ''));\n    }\n    if (parts.length === 1) {\n        return obj[key];\n    }\n    return getValue(obj[key], parts.slice(1).join('.'));\n}\nfunction getExtraValue(instance, dataPathsArray) {\n    let context = instance;\n    dataPathsArray.forEach(dataPathArray => {\n        const dataPath = dataPathArray[0];\n        const value = dataPathArray[2];\n        if (dataPath || typeof value !== 'undefined') {\n            // ['','',index,'disable']\n            const propPath = dataPathArray[1];\n            const valuePath = dataPathArray[3];\n            let vFor;\n            if (Number.isInteger(dataPath)) {\n                vFor = dataPath;\n            }\n            else if (!dataPath) {\n                vFor = context;\n            }\n            else if (typeof dataPath === 'string' && dataPath) {\n                if (dataPath.indexOf('#s#') === 0) {\n                    vFor = dataPath.substr(3);\n                }\n                else {\n                    vFor = getValue(context, dataPath);\n                }\n            }\n            if (Number.isInteger(vFor)) {\n                context = value;\n            }\n            else if (!propPath) {\n                context = vFor[value];\n            }\n            else {\n                if (isArray(vFor)) {\n                    context = vFor.find(vForItem => {\n                        return getValue(vForItem, propPath) === value;\n                    });\n                }\n                else if (isPlainObject(vFor)) {\n                    context = Object.keys(vFor).find(vForKey => {\n                        return getValue(vFor[vForKey], propPath) === value;\n                    });\n                }\n                else {\n                    console.error('v-for 暂不支持循环数据：', vFor);\n                }\n            }\n            if (valuePath) {\n                context = getValue(context, valuePath);\n            }\n        }\n    });\n    return context;\n}\nfunction processEventExtra(instance, extra, event) {\n    const extraObj = {};\n    if (isArray(extra) && extra.length) {\n        /**\n         *[\n         *    ['data.items', 'data.id', item.data.id],\n         *    ['metas', 'id', meta.id]\n         *],\n         *[\n         *    ['data.items', 'data.id', item.data.id],\n         *    ['metas', 'id', meta.id]\n         *],\n         *'test'\n         */\n        extra.forEach((dataPath, index) => {\n            if (typeof dataPath === 'string') {\n                if (!dataPath) {\n                    // model,prop.sync\n                    extraObj['$' + index] = instance;\n                }\n                else {\n                    if (dataPath === '$event') {\n                        // $event\n                        extraObj['$' + index] = event;\n                    }\n                    else if (dataPath === 'arguments') {\n                        if (event.detail && event.detail.__args__) {\n                            extraObj['$' + index] = event.detail.__args__;\n                        }\n                        else {\n                            extraObj['$' + index] = [event];\n                        }\n                    }\n                    else if (dataPath.indexOf('$event.') === 0) {\n                        // $event.target.value\n                        extraObj['$' + index] = getValue(event, dataPath.replace('$event.', ''));\n                    }\n                    else {\n                        extraObj['$' + index] = getValue(instance, dataPath);\n                    }\n                }\n            }\n            else {\n                extraObj['$' + index] = getExtraValue(instance, dataPath);\n            }\n        });\n    }\n    return extraObj;\n}\nfunction getObjByArray(arr) {\n    const obj = {};\n    for (let i = 1; i < arr.length; i++) {\n        const element = arr[i];\n        obj[element[0]] = element[1];\n    }\n    return obj;\n}\nfunction processEventArgs(instance, event, args = [], extra = [], isCustom, methodName) {\n    let isCustomMPEvent = false; // wxcomponent 组件，传递原始 event 对象\n    if (isCustom) {\n        // 自定义事件\n        isCustomMPEvent =\n            event.currentTarget &&\n                event.currentTarget.dataset &&\n                event.currentTarget.dataset.comType === 'wx';\n        if (!args.length) {\n            // 无参数，直接传入 event 或 detail 数组\n            if (isCustomMPEvent) {\n                return [event];\n            }\n            return event.detail.__args__ || event.detail;\n        }\n    }\n    const extraObj = processEventExtra(instance, extra, event);\n    const ret = [];\n    args.forEach(arg => {\n        if (arg === '$event') {\n            if (methodName === '__set_model' && !isCustom) {\n                // input v-model value\n                ret.push(event.target.value);\n            }\n            else {\n                if (isCustom && !isCustomMPEvent) {\n                    ret.push(event.detail.__args__[0]);\n                }\n                else {\n                    // wxcomponent 组件或内置组件\n                    ret.push(event);\n                }\n            }\n        }\n        else {\n            if (isArray(arg) && arg[0] === 'o') {\n                ret.push(getObjByArray(arg));\n            }\n            else if (typeof arg === 'string' && hasOwn(extraObj, arg)) {\n                ret.push(extraObj[arg]);\n            }\n            else {\n                ret.push(arg);\n            }\n        }\n    });\n    return ret;\n}\nfunction wrapper(event) {\n    event.stopPropagation = NOOP;\n    event.preventDefault = NOOP;\n    event.target = event.target || {};\n    if (!hasOwn(event, 'detail')) {\n        event.detail = {};\n    }\n    if (hasOwn(event, 'markerId')) {\n        event.detail = typeof event.detail === 'object' ? event.detail : {};\n        event.detail.markerId = event.markerId;\n    }\n    if (isPlainObject(event.detail)) {\n        event.target = Object.assign({}, event.target, event.detail);\n    }\n    return event;\n}\nconst ONCE = '~';\nconst CUSTOM = '^';\nfunction matchEventType(eventType, optType) {\n    return (eventType === optType ||\n        (optType === 'regionchange' &&\n            (eventType === 'begin' || eventType === 'end')));\n}\nfunction handleEvent(event) {\n    event = wrapper(event);\n    // [['tap',[['handle',[1,2,a]],['handle1',[1,2,a]]]]]\n    const dataset = (event.currentTarget || event.target).dataset;\n    if (!dataset) {\n        return console.warn('事件信息不存在');\n    }\n    const eventOpts = (dataset.eventOpts ||\n        dataset['event-opts']); // 支付宝 web-view 组件 dataset 非驼峰\n    if (!eventOpts) {\n        return console.warn('事件信息不存在');\n    }\n    // [['handle',[1,2,a]],['handle1',[1,2,a]]]\n    const eventType = event.type;\n    const ret = [];\n    eventOpts.forEach((eventOpt) => {\n        let type = eventOpt[0];\n        const eventsArray = eventOpt[1];\n        const isCustom = type.charAt(0) === CUSTOM;\n        type = isCustom ? type.slice(1) : type;\n        const isOnce = type.charAt(0) === ONCE;\n        type = isOnce ? type.slice(1) : type;\n        if (eventsArray && matchEventType(eventType, type)) {\n            eventsArray.forEach((eventArray) => {\n                const methodName = eventArray[0];\n                if (methodName) {\n                    let handlerCtx = this.$vm;\n                    if (handlerCtx.$options.generic &&\n                        handlerCtx.$parent &&\n                        handlerCtx.$parent.$parent) {\n                        // mp-weixin,mp-toutiao 抽象节点模拟 scoped slots\n                        handlerCtx = handlerCtx.$parent.$parent;\n                    }\n                    if (methodName === '$emit') {\n                        handlerCtx.$emit.apply(handlerCtx, processEventArgs(this.$vm, event, eventArray[1], eventArray[2], isCustom, methodName));\n                        return;\n                    }\n                    const handler = handlerCtx[methodName];\n                    if (!isFunction(handler)) {\n                        throw new Error(` _vm.${methodName} is not a function`);\n                    }\n                    if (isOnce) {\n                        if (handler.once) {\n                            return;\n                        }\n                        handler.once = true;\n                    }\n                    ret.push(handler.apply(handlerCtx, processEventArgs(this.$vm, event, eventArray[1], eventArray[2], isCustom, methodName)));\n                }\n            });\n        }\n    });\n    if (eventType === 'input' &&\n        ret.length === 1 &&\n        typeof ret[0] !== 'undefined') {\n        return ret[0];\n    }\n}\n\nfunction parseComponent(vueOptions, { parse, mocks, isPage, initRelation, handleLink, initLifetimes }) {\n    vueOptions = vueOptions.default || vueOptions;\n    const options = {\n        multipleSlots: true,\n        addGlobalClass: true\n    };\n    if (vueOptions.options) {\n        extend(options, vueOptions.options);\n    }\n    const mpComponentOptions = {\n        options,\n        lifetimes: initLifetimes({ mocks, isPage, initRelation, vueOptions }),\n        pageLifetimes: {\n            show() {\n                this.$vm && this.$vm.$callHook('onPageShow');\n            },\n            hide() {\n                this.$vm && this.$vm.$callHook('onPageHide');\n            },\n            resize(size) {\n                this.$vm && this.$vm.$callHook('onPageResize', size);\n            }\n        },\n        methods: {\n            __l: handleLink,\n            __e: handleEvent\n        }\n    };\n    if (__VUE_OPTIONS_API__) {\n        applyOptions(mpComponentOptions, vueOptions, initBehavior);\n    }\n    initProps(mpComponentOptions, vueOptions.props, false);\n    initExtraOptions(mpComponentOptions, vueOptions);\n    initWxsCallMethods(mpComponentOptions.methods, vueOptions.wxsCallMethods);\n    if (parse) {\n        parse(mpComponentOptions, { handleLink });\n    }\n    return mpComponentOptions;\n}\nfunction initCreateComponent(parseOptions) {\n    return function createComponent(vueComponentOptions) {\n        return Component(parseComponent(vueComponentOptions, parseOptions));\n    };\n}\nlet $createComponentFn;\nlet $destroyComponentFn;\nfunction $createComponent(initialVNode, options) {\n    if (!$createComponentFn) {\n        $createComponentFn = getApp().$vm.$createComponent;\n    }\n    return $createComponentFn(initialVNode, options);\n}\nfunction $destroyComponent(instance) {\n    if (!$destroyComponentFn) {\n        $destroyComponentFn = getApp().$vm.$destroyComponent;\n    }\n    return $destroyComponentFn(instance);\n}\n\nfunction parsePage(vueOptions, parseOptions) {\n    const { parse, mocks, isPage, initRelation, handleLink, initLifetimes } = parseOptions;\n    const miniProgramPageOptions = parseComponent(vueOptions, {\n        mocks,\n        isPage,\n        initRelation,\n        handleLink,\n        initLifetimes\n    });\n    const methods = miniProgramPageOptions.methods;\n    methods.onLoad = function (query) {\n        this.options = query;\n        this.$page = {\n            fullPath: '/' + this.route + stringifyQuery(query)\n        };\n        return this.$vm && this.$vm.$callHook('onLoad', query);\n    };\n    initHooks(methods, PAGE_HOOKS);\n    initUnknownHooks(methods, vueOptions);\n    parse && parse(miniProgramPageOptions, { handleLink });\n    return miniProgramPageOptions;\n}\nfunction initCreatePage(parseOptions) {\n    return function createPage(vuePageOptions) {\n        return Component(parsePage(vuePageOptions, parseOptions));\n    };\n}\n\nconst MPPage = Page;\nconst MPComponent = Component;\nconst customizeRE = /:/g;\nfunction customize(str) {\n    return camelize(str.replace(customizeRE, '-'));\n}\nfunction initTriggerEvent(mpInstance) {\n    const oldTriggerEvent = mpInstance.triggerEvent;\n    mpInstance.triggerEvent = function (event, ...args) {\n        return oldTriggerEvent.apply(mpInstance, [customize(event), ...args]);\n    };\n}\nfunction initHook$1(name, options) {\n    const oldHook = options[name];\n    if (!oldHook) {\n        options[name] = function () {\n            initTriggerEvent(this);\n        };\n    }\n    else {\n        options[name] = function (...args) {\n            initTriggerEvent(this);\n            return oldHook.apply(this, args);\n        };\n    }\n}\nPage = function (options) {\n    initHook$1('onLoad', options);\n    return MPPage(options);\n};\nComponent = function (options) {\n    initHook$1('created', options);\n    return MPComponent(options);\n};\n\nfunction initLifetimes({ mocks, isPage, initRelation, vueOptions }) {\n    return {\n        attached() {\n            const properties = this.properties;\n            initVueIds(properties.vueId, this);\n            const relationOptions = {\n                vuePid: this._$vuePid\n            };\n            // 处理父子关系\n            initRelation(this, relationOptions);\n            // 初始化 vue 实例\n            const mpInstance = this;\n            this.$vm = $createComponent({\n                type: vueOptions,\n                props: properties\n            }, {\n                mpType: isPage(mpInstance) ? 'page' : 'component',\n                mpInstance,\n                slots: properties.vueSlots,\n                parentComponent: relationOptions.parent && relationOptions.parent.$,\n                onBeforeSetup(instance, options) {\n                    initRefs(instance, mpInstance);\n                    initMocks(instance, mpInstance, mocks);\n                    initComponentInstance(instance, options);\n                }\n            });\n        },\n        ready() {\n            // 当组件 props 默认值为 true，初始化时传入 false 会导致 created,ready 触发, 但 attached 不触发\n            // https://developers.weixin.qq.com/community/develop/doc/00066ae2844cc0f8eb883e2a557800\n            if (this.$vm) {\n                this.$vm.$callHook('mounted');\n                this.$vm.$callHook('onReady');\n            }\n        },\n        detached() {\n            this.$vm && $destroyComponent(this.$vm);\n        }\n    };\n}\n\nconst mocks = ['__route__', '__wxExparserNodeId__', '__wxWebviewId__'];\nfunction isPage(mpInstance) {\n    return !!mpInstance.route;\n}\nfunction initRelation(mpInstance, detail) {\n    mpInstance.triggerEvent('__l', detail);\n}\nfunction handleLink(event) {\n    // detail 是微信,value 是百度(dipatch)\n    const detail = (event.detail ||\n        event.value);\n    const vuePid = detail.vuePid;\n    let parentVm;\n    if (vuePid) {\n        parentVm = findVmByVueId(this.$vm, vuePid);\n    }\n    if (!parentVm) {\n        parentVm = this.$vm;\n    }\n    detail.parent = parentVm;\n}\n\nvar parseOptions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mocks: mocks,\n  isPage: isPage,\n  initRelation: initRelation,\n  handleLink: handleLink,\n  initLifetimes: initLifetimes\n});\n\nconst createApp = initCreateApp();\nconst createPage = initCreatePage(parseOptions);\nconst createComponent = initCreateComponent(parseOptions);\n\nexport { createApp, createComponent, createPage };\n","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode, /* vue-cli only */\n  components, // fixed by xxxxxx auto components\n  renderjs // fixed by xxxxxx renderjs\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // fixed by xxxxxx auto components\n  if (components) {\n    if (!options.components) {\n      options.components = {}\n    }\n    var hasOwn = Object.prototype.hasOwnProperty\n    for (var name in components) {\n      if (hasOwn.call(components, name) && !hasOwn.call(options.components, name)) {\n        options.components[name] = components[name]\n      }\n    }\n  }\n  // fixed by xxxxxx renderjs\n  if (renderjs) {\n    (renderjs.beforeCreate || (renderjs.beforeCreate = [])).unshift(function() {\n      this[renderjs.__module] = this\n    });\n    (options.mixins || (options.mixins = [])).push(renderjs)\n  }\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n"],"sourceRoot":""}